<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>5.1 Polígonos regulares | MCTA008-17 Computação Gráfica</title>
  <meta name="description" content="Notas de aula de MCTA008-17 Computação Gráfica da Universidade Federal do ABC" />
  <meta name="generator" content="bookdown 0.21.2 and GitBook 2.6.7" />

  <meta property="og:title" content="5.1 Polígonos regulares | MCTA008-17 Computação Gráfica" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Notas de aula de MCTA008-17 Computação Gráfica da Universidade Federal do ABC" />
  <meta name="github-repo" content="hbatagelo/cgbook" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="5.1 Polígonos regulares | MCTA008-17 Computação Gráfica" />
  
  <meta name="twitter:description" content="Notas de aula de MCTA008-17 Computação Gráfica da Universidade Federal do ABC" />
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="game.html"/>
<link rel="next" href="asteroids.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<script src="libs/accessible-code-block-0.0.1/empty-anchor.js"></script>


<style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { font-weight: bold; } /* Alert */
code span.an { font-style: italic; } /* Annotation */
code span.cf { font-weight: bold; } /* ControlFlow */
code span.co { font-style: italic; } /* Comment */
code span.cv { font-style: italic; } /* CommentVar */
code span.do { font-style: italic; } /* Documentation */
code span.dt { text-decoration: underline; } /* DataType */
code span.er { font-weight: bold; } /* Error */
code span.in { font-style: italic; } /* Information */
code span.kw { font-weight: bold; } /* Keyword */
code span.pp { font-weight: bold; } /* Preprocessor */
code span.wa { font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Computação Gráfica</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Apresentação</a><ul>
<li class="chapter" data-level="" data-path="pré-requisitos.html"><a href="pré-requisitos.html"><i class="fa fa-check"></i>Pré-requisitos</a><ul>
<li class="chapter" data-level="" data-path="pré-requisitos.html"><a href="pré-requisitos.html#atividades-práticas"><i class="fa fa-check"></i>Atividades práticas</a></li>
<li class="chapter" data-level="" data-path="pré-requisitos.html"><a href="pré-requisitos.html#visualizando-este-site"><i class="fa fa-check"></i>Visualizando este site</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="1" data-path="config.html"><a href="config.html"><i class="fa fa-check"></i><b>1</b> Configuração do ambiente</a><ul>
<li class="chapter" data-level="1.1" data-path="linux.html"><a href="linux.html"><i class="fa fa-check"></i><b>1.1</b> Linux</a><ul>
<li class="chapter" data-level="" data-path="linux.html"><a href="linux.html#habilitando-o-opengl"><i class="fa fa-check"></i>Habilitando o OpenGL</a></li>
<li class="chapter" data-level="" data-path="linux.html"><a href="linux.html#atualizando-o-gcc"><i class="fa fa-check"></i>Atualizando o GCC</a></li>
<li class="chapter" data-level="" data-path="linux.html"><a href="linux.html#instalando-o-emscripten"><i class="fa fa-check"></i>Instalando o Emscripten</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="macos.html"><a href="macos.html"><i class="fa fa-check"></i><b>1.2</b> macOS</a><ul>
<li class="chapter" data-level="" data-path="macos.html"><a href="macos.html#instalando-o-emscripten-1"><i class="fa fa-check"></i>Instalando o Emscripten</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="windows.html"><a href="windows.html"><i class="fa fa-check"></i><b>1.3</b> Windows</a><ul>
<li class="chapter" data-level="" data-path="windows.html"><a href="windows.html#habilitando-o-opengl-1"><i class="fa fa-check"></i>Habilitando o OpenGL</a></li>
<li class="chapter" data-level="" data-path="windows.html"><a href="windows.html#instalando-o-emscripten-2"><i class="fa fa-check"></i>Instalando o Emscripten</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="vscode.html"><a href="vscode.html"><i class="fa fa-check"></i><b>1.4</b> Visual Studio Code</a></li>
<li class="chapter" data-level="1.5" data-path="abcg.html"><a href="abcg.html"><i class="fa fa-check"></i><b>1.5</b> ABCg</a><ul>
<li class="chapter" data-level="" data-path="abcg.html"><a href="abcg.html#instalação"><i class="fa fa-check"></i>Instalação</a></li>
<li class="chapter" data-level="" data-path="abcg.html"><a href="abcg.html#compilando-em-linha-de-comando"><i class="fa fa-check"></i>Compilando em linha de comando</a></li>
<li class="chapter" data-level="" data-path="abcg.html"><a href="abcg.html#compilando-no-visual-studio-code"><i class="fa fa-check"></i>Compilando no Visual Studio Code</a></li>
<li class="chapter" data-level="" data-path="abcg.html"><a href="abcg.html#depurando-no-visual-studio-code"><i class="fa fa-check"></i>Depurando no Visual Studio Code</a></li>
<li class="chapter" data-level="" data-path="abcg.html"><a href="abcg.html#compilando-para-webassembly"><i class="fa fa-check"></i>Compilando para WebAssembly</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>2</b> Introdução</a><ul>
<li class="chapter" data-level="2.1" data-path="áreas-correlatas.html"><a href="áreas-correlatas.html"><i class="fa fa-check"></i><b>2.1</b> Áreas correlatas</a></li>
<li class="chapter" data-level="2.2" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html"><i class="fa fa-check"></i><b>2.2</b> Linha do tempo</a><ul>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section"><i class="fa fa-check"></i>1950</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-1"><i class="fa fa-check"></i>1960</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-2"><i class="fa fa-check"></i>1970</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-3"><i class="fa fa-check"></i>1980</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-4"><i class="fa fa-check"></i>1990</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-5"><i class="fa fa-check"></i>2000</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-6"><i class="fa fa-check"></i>2010</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-7"><i class="fa fa-check"></i>2020</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="firstapp.html"><a href="firstapp.html"><i class="fa fa-check"></i><b>2.3</b> Primeiro programa</a><ul>
<li class="chapter" data-level="" data-path="firstapp.html"><a href="firstapp.html#configuração-inicial"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="firstapp.html"><a href="firstapp.html#main.cpp"><i class="fa fa-check"></i>main.cpp</a></li>
<li class="chapter" data-level="" data-path="firstapp.html"><a href="firstapp.html#openglwindow.hpp"><i class="fa fa-check"></i>openglwindow.hpp</a></li>
<li class="chapter" data-level="" data-path="firstapp.html"><a href="firstapp.html#openglwindow.cpp"><i class="fa fa-check"></i>openglwindow.cpp</a></li>
<li class="chapter" data-level="" data-path="firstapp.html"><a href="firstapp.html#compilando-para-webassembly-1"><i class="fa fa-check"></i>Compilando para WebAssembly</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="graphicssystem.html"><a href="graphicssystem.html"><i class="fa fa-check"></i><b>3</b> Sistemas gráficos</a><ul>
<li class="chapter" data-level="3.1" data-path="vectorxraster.html"><a href="vectorxraster.html"><i class="fa fa-check"></i><b>3.1</b> Vetorial <em>x</em> matricial</a><ul>
<li class="chapter" data-level="" data-path="vectorxraster.html"><a href="vectorxraster.html#representação-vetorial"><i class="fa fa-check"></i>Representação vetorial</a></li>
<li class="chapter" data-level="" data-path="vectorxraster.html"><a href="vectorxraster.html#representação-matricial"><i class="fa fa-check"></i>Representação matricial</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="es.html"><a href="es.html"><i class="fa fa-check"></i><b>3.2</b> Dispositivos de E/S</a><ul>
<li class="chapter" data-level="" data-path="es.html"><a href="es.html#dispositivos-de-entrada"><i class="fa fa-check"></i>Dispositivos de entrada</a></li>
<li class="chapter" data-level="" data-path="es.html"><a href="es.html#dispositivos-de-saída"><i class="fa fa-check"></i>Dispositivos de saída</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="framebuffer.html"><a href="framebuffer.html"><i class="fa fa-check"></i><b>3.3</b> Framebuffer</a><ul>
<li class="chapter" data-level="" data-path="framebuffer.html"><a href="framebuffer.html#screen-tearing"><i class="fa fa-check"></i>Screen tearing</a></li>
<li class="chapter" data-level="" data-path="framebuffer.html"><a href="framebuffer.html#vsync"><i class="fa fa-check"></i>Vsync</a></li>
<li class="chapter" data-level="" data-path="framebuffer.html"><a href="framebuffer.html#backbuffering"><i class="fa fa-check"></i>Backbuffering</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="sierpinski.html"><a href="sierpinski.html"><i class="fa fa-check"></i><b>3.4</b> Triângulo de Sierpinski</a><ul>
<li class="chapter" data-level="" data-path="sierpinski.html"><a href="sierpinski.html#configuração-inicial-1"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="sierpinski.html"><a href="sierpinski.html#main.cpp-1"><i class="fa fa-check"></i>main.cpp</a></li>
<li class="chapter" data-level="" data-path="sierpinski.html"><a href="sierpinski.html#openglwindow.hpp-1"><i class="fa fa-check"></i>openglwindow.hpp</a></li>
<li class="chapter" data-level="" data-path="sierpinski.html"><a href="sierpinski.html#openglwindow.cpp-1"><i class="fa fa-check"></i>openglwindow.cpp</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="pipeline.html"><a href="pipeline.html"><i class="fa fa-check"></i><b>4</b> Pipeline gráfico</a><ul>
<li class="chapter" data-level="4.1" data-path="dados-gráficos.html"><a href="dados-gráficos.html"><i class="fa fa-check"></i><b>4.1</b> Dados gráficos</a></li>
<li class="chapter" data-level="4.2" data-path="ray-casting-x-rasterização.html"><a href="ray-casting-x-rasterização.html"><i class="fa fa-check"></i><b>4.2</b> Ray casting <em>x</em> rasterização</a><ul>
<li class="chapter" data-level="" data-path="ray-casting-x-rasterização.html"><a href="ray-casting-x-rasterização.html#ray-casting"><i class="fa fa-check"></i>Ray casting</a></li>
<li class="chapter" data-level="" data-path="ray-casting-x-rasterização.html"><a href="ray-casting-x-rasterização.html#rasterização"><i class="fa fa-check"></i>Rasterização</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="glpipeline.html"><a href="glpipeline.html"><i class="fa fa-check"></i><b>4.3</b> Pipeline do OpenGL</a><ul>
<li class="chapter" data-level="" data-path="glpipeline.html"><a href="glpipeline.html#aplicação"><i class="fa fa-check"></i>Aplicação</a></li>
<li class="chapter" data-level="" data-path="glpipeline.html"><a href="glpipeline.html#vertex-shader"><i class="fa fa-check"></i>Vertex shader</a></li>
<li class="chapter" data-level="" data-path="glpipeline.html"><a href="glpipeline.html#montagem-de-primitivas"><i class="fa fa-check"></i>Montagem de primitivas</a></li>
<li class="chapter" data-level="" data-path="glpipeline.html"><a href="glpipeline.html#recorte"><i class="fa fa-check"></i>Recorte</a></li>
<li class="chapter" data-level="" data-path="glpipeline.html"><a href="glpipeline.html#rasterização-1"><i class="fa fa-check"></i>Rasterização</a></li>
<li class="chapter" data-level="" data-path="glpipeline.html"><a href="glpipeline.html#fragment-shader"><i class="fa fa-check"></i>Fragment shader</a></li>
<li class="chapter" data-level="" data-path="glpipeline.html"><a href="glpipeline.html#operações-de-fragmentos"><i class="fa fa-check"></i>Operações de fragmentos</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="coloredtriangles.html"><a href="coloredtriangles.html"><i class="fa fa-check"></i><b>4.4</b> Triângulos coloridos</a><ul>
<li class="chapter" data-level="" data-path="coloredtriangles.html"><a href="coloredtriangles.html#configuração-inicial-2"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="coloredtriangles.html"><a href="coloredtriangles.html#main.cpp-2"><i class="fa fa-check"></i>main.cpp</a></li>
<li class="chapter" data-level="" data-path="coloredtriangles.html"><a href="coloredtriangles.html#openglwindow.hpp-2"><i class="fa fa-check"></i>openglwindow.hpp</a></li>
<li class="chapter" data-level="" data-path="coloredtriangles.html"><a href="coloredtriangles.html#openglwindow.cpp-2"><i class="fa fa-check"></i>openglwindow.cpp</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="game.html"><a href="game.html"><i class="fa fa-check"></i><b>5</b> Desenvolvendo um jogo 2D</a><ul>
<li class="chapter" data-level="5.1" data-path="regularpolygons.html"><a href="regularpolygons.html"><i class="fa fa-check"></i><b>5.1</b> Polígonos regulares</a><ul>
<li class="chapter" data-level="" data-path="regularpolygons.html"><a href="regularpolygons.html#configuração-inicial-3"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="regularpolygons.html"><a href="regularpolygons.html#main.cpp-3"><i class="fa fa-check"></i>main.cpp</a></li>
<li class="chapter" data-level="" data-path="regularpolygons.html"><a href="regularpolygons.html#openglwindow.hpp-3"><i class="fa fa-check"></i>openglwindow.hpp</a></li>
<li class="chapter" data-level="" data-path="regularpolygons.html"><a href="regularpolygons.html#openglwindow.cpp-3"><i class="fa fa-check"></i>openglwindow.cpp</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="asteroids.html"><a href="asteroids.html"><i class="fa fa-check"></i><b>5.2</b> Asteroids</a><ul>
<li class="chapter" data-level="" data-path="asteroids.html"><a href="asteroids.html#organização-do-projeto"><i class="fa fa-check"></i>Organização do projeto</a></li>
<li class="chapter" data-level="" data-path="asteroids.html"><a href="asteroids.html#configuração-inicial-4"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="asteroids.html"><a href="asteroids.html#nave"><i class="fa fa-check"></i>Nave</a></li>
<li class="chapter" data-level="" data-path="asteroids.html"><a href="asteroids.html#estrelas"><i class="fa fa-check"></i>Estrelas</a></li>
<li class="chapter" data-level="" data-path="asteroids.html"><a href="asteroids.html#asteroides"><i class="fa fa-check"></i>Asteroides</a></li>
<li class="chapter" data-level="" data-path="asteroids.html"><a href="asteroids.html#tiros-e-colisões"><i class="fa fa-check"></i>Tiros e colisões</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="geometry.html"><a href="geometry.html"><i class="fa fa-check"></i><b>6</b> Espaços e geometria</a><ul>
<li class="chapter" data-level="6.1" data-path="vector.html"><a href="vector.html"><i class="fa fa-check"></i><b>6.1</b> Espaço vetorial</a><ul>
<li class="chapter" data-level="" data-path="vector.html"><a href="vector.html#combinação-e-independência-linear"><i class="fa fa-check"></i>Combinação e independência linear</a></li>
<li class="chapter" data-level="" data-path="vector.html"><a href="vector.html#dimensão-e-base"><i class="fa fa-check"></i>Dimensão e base</a></li>
<li class="chapter" data-level="" data-path="vector.html"><a href="vector.html#vetores-geométricos"><i class="fa fa-check"></i>Vetores geométricos</a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="affine.html"><a href="affine.html"><i class="fa fa-check"></i><b>6.2</b> Espaço afim</a><ul>
<li class="chapter" data-level="" data-path="affine.html"><a href="affine.html#combinação-afim"><i class="fa fa-check"></i>Combinação afim</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="euclidean.html"><a href="euclidean.html"><i class="fa fa-check"></i><b>6.3</b> Espaço euclidiano</a><ul>
<li class="chapter" data-level="" data-path="euclidean.html"><a href="euclidean.html#frames"><i class="fa fa-check"></i>Frames</a></li>
<li class="chapter" data-level="" data-path="euclidean.html"><a href="euclidean.html#produto-escalar"><i class="fa fa-check"></i>Produto escalar</a></li>
<li class="chapter" data-level="" data-path="euclidean.html"><a href="euclidean.html#ortogonalidade"><i class="fa fa-check"></i>Ortogonalidade</a></li>
<li class="chapter" data-level="" data-path="euclidean.html"><a href="euclidean.html#comprimento-e-distância"><i class="fa fa-check"></i>Comprimento e distância</a></li>
<li class="chapter" data-level="" data-path="euclidean.html"><a href="euclidean.html#normalização"><i class="fa fa-check"></i>Normalização</a></li>
<li class="chapter" data-level="" data-path="euclidean.html"><a href="euclidean.html#ângulo-entre-vetores"><i class="fa fa-check"></i>Ângulo entre vetores</a></li>
<li class="chapter" data-level="" data-path="euclidean.html"><a href="euclidean.html#projeção-ortogonal"><i class="fa fa-check"></i>Projeção ortogonal</a></li>
<li class="chapter" data-level="" data-path="euclidean.html"><a href="euclidean.html#produto-vetorial"><i class="fa fa-check"></i>Produto vetorial</a></li>
<li class="chapter" data-level="" data-path="euclidean.html"><a href="euclidean.html#vetor-normal"><i class="fa fa-check"></i>Vetor normal</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="objmodel.html"><a href="objmodel.html"><i class="fa fa-check"></i><b>6.4</b> Lendo um modelo 3D</a><ul>
<li class="chapter" data-level="" data-path="objmodel.html"><a href="objmodel.html#orientação-e-face-culling"><i class="fa fa-check"></i>Orientação e face culling</a></li>
<li class="chapter" data-level="" data-path="objmodel.html"><a href="objmodel.html#configuração-inicial-5"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="objmodel.html"><a href="objmodel.html#main.cpp-5"><i class="fa fa-check"></i>main.cpp</a></li>
<li class="chapter" data-level="" data-path="objmodel.html"><a href="objmodel.html#loadmodel.vert"><i class="fa fa-check"></i>loadmodel.vert</a></li>
<li class="chapter" data-level="" data-path="objmodel.html"><a href="objmodel.html#loadmodel.frag"><i class="fa fa-check"></i>loadmodel.frag</a></li>
<li class="chapter" data-level="" data-path="objmodel.html"><a href="objmodel.html#openglwindow.hpp-5"><i class="fa fa-check"></i>openglwindow.hpp</a></li>
<li class="chapter" data-level="" data-path="objmodel.html"><a href="objmodel.html#openglwindow.cpp-5"><i class="fa fa-check"></i>openglwindow.cpp</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="7" data-path="transformations.html"><a href="transformations.html"><i class="fa fa-check"></i><b>7</b> Matrizes e transformações</a><ul>
<li class="chapter" data-level="7.1" data-path="matrix.html"><a href="matrix.html"><i class="fa fa-check"></i><b>7.1</b> Matrizes</a><ul>
<li class="chapter" data-level="" data-path="matrix.html"><a href="matrix.html#matriz-transposta"><i class="fa fa-check"></i>Matriz transposta</a></li>
<li class="chapter" data-level="" data-path="matrix.html"><a href="matrix.html#matriz-quadrada"><i class="fa fa-check"></i>Matriz quadrada</a></li>
<li class="chapter" data-level="" data-path="matrix.html"><a href="matrix.html#matriz-linhacoluna"><i class="fa fa-check"></i>Matriz linha/coluna</a></li>
<li class="chapter" data-level="" data-path="matrix.html"><a href="matrix.html#matriz-identidade"><i class="fa fa-check"></i>Matriz identidade</a></li>
<li class="chapter" data-level="" data-path="matrix.html"><a href="matrix.html#operações"><i class="fa fa-check"></i>Operações</a></li>
<li class="chapter" data-level="" data-path="matrix.html"><a href="matrix.html#matriz-inversa"><i class="fa fa-check"></i>Matriz inversa</a></li>
<li class="chapter" data-level="" data-path="matrix.html"><a href="matrix.html#matriz-ortogonal"><i class="fa fa-check"></i>Matriz ortogonal</a></li>
<li class="chapter" data-level="" data-path="matrix.html"><a href="matrix.html#propriedades"><i class="fa fa-check"></i>Propriedades</a></li>
<li class="chapter" data-level="" data-path="matrix.html"><a href="matrix.html#transformação"><i class="fa fa-check"></i>Transformação</a></li>
</ul></li>
<li class="chapter" data-level="7.2" data-path="homogeneous.html"><a href="homogeneous.html"><i class="fa fa-check"></i><b>7.2</b> Coordenadas homogêneas</a></li>
<li class="chapter" data-level="7.3" data-path="concat.html"><a href="concat.html"><i class="fa fa-check"></i><b>7.3</b> Concatenação de transformações</a></li>
<li class="chapter" data-level="7.4" data-path="transforms.html"><a href="transforms.html"><i class="fa fa-check"></i><b>7.4</b> Transformações</a><ul>
<li class="chapter" data-level="" data-path="transforms.html"><a href="transforms.html#identidade"><i class="fa fa-check"></i>Identidade</a></li>
<li class="chapter" data-level="" data-path="transforms.html"><a href="transforms.html#translação"><i class="fa fa-check"></i>Translação</a></li>
<li class="chapter" data-level="" data-path="transforms.html"><a href="transforms.html#escala"><i class="fa fa-check"></i>Escala</a></li>
<li class="chapter" data-level="" data-path="transforms.html"><a href="transforms.html#rotação"><i class="fa fa-check"></i>Rotação</a></li>
</ul></li>
<li class="chapter" data-level="7.5" data-path="glspaces.html"><a href="glspaces.html"><i class="fa fa-check"></i><b>7.5</b> Espaços do OpenGL</a><ul>
<li class="chapter" data-level="" data-path="glspaces.html"><a href="glspaces.html#espaço-do-objeto"><i class="fa fa-check"></i>Espaço do objeto</a></li>
<li class="chapter" data-level="" data-path="glspaces.html"><a href="glspaces.html#espaço-do-mundo"><i class="fa fa-check"></i>Espaço do mundo</a></li>
<li class="chapter" data-level="" data-path="glspaces.html"><a href="glspaces.html#espaço-da-câmera"><i class="fa fa-check"></i>Espaço da câmera</a></li>
<li class="chapter" data-level="" data-path="glspaces.html"><a href="glspaces.html#concatenação-das-matrizes-de-modelo-e-visão"><i class="fa fa-check"></i>Concatenação das matrizes de modelo e visão</a></li>
</ul></li>
<li class="chapter" data-level="7.6" data-path="lookat.html"><a href="lookat.html"><i class="fa fa-check"></i><b>7.6</b> Câmera LookAt</a><ul>
<li class="chapter" data-level="" data-path="lookat.html"><a href="lookat.html#construindo-o-vetor-n"><i class="fa fa-check"></i>Construindo o vetor n</a></li>
<li class="chapter" data-level="" data-path="lookat.html"><a href="lookat.html#construindo-o-vetor-u"><i class="fa fa-check"></i>Construindo o vetor u</a></li>
<li class="chapter" data-level="" data-path="lookat.html"><a href="lookat.html#construindo-o-vetor-v"><i class="fa fa-check"></i>Construindo o vetor v</a></li>
<li class="chapter" data-level="" data-path="lookat.html"><a href="lookat.html#construindo-a-matriz-de-visão"><i class="fa fa-check"></i>Construindo a matriz de visão</a></li>
</ul></li>
<li class="chapter" data-level="7.7" data-path="lookatproject.html"><a href="lookatproject.html"><i class="fa fa-check"></i><b>7.7</b> LookAt na prática</a><ul>
<li class="chapter" data-level="" data-path="lookatproject.html"><a href="lookatproject.html#configuração-inicial-6"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="lookatproject.html"><a href="lookatproject.html#main.cpp-6"><i class="fa fa-check"></i>main.cpp</a></li>
<li class="chapter" data-level="" data-path="lookatproject.html"><a href="lookatproject.html#lookat.vert"><i class="fa fa-check"></i>lookat.vert</a></li>
<li class="chapter" data-level="" data-path="lookatproject.html"><a href="lookatproject.html#lookat.frag"><i class="fa fa-check"></i>lookat.frag</a></li>
<li class="chapter" data-level="" data-path="lookatproject.html"><a href="lookatproject.html#camera.hpp"><i class="fa fa-check"></i>camera.hpp</a></li>
<li class="chapter" data-level="" data-path="lookatproject.html"><a href="lookatproject.html#camera.cpp"><i class="fa fa-check"></i>camera.cpp</a></li>
<li class="chapter" data-level="" data-path="lookatproject.html"><a href="lookatproject.html#openglwindow.hpp-6"><i class="fa fa-check"></i>openglwindow.hpp</a></li>
<li class="chapter" data-level="" data-path="lookatproject.html"><a href="lookatproject.html#openglwindow.cpp-6"><i class="fa fa-check"></i>openglwindow.cpp</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="8" data-path="projections.html"><a href="projections.html"><i class="fa fa-check"></i><b>8</b> Projeções e trackball virtual</a><ul>
<li class="chapter" data-level="8.1" data-path="ortho.html"><a href="ortho.html"><i class="fa fa-check"></i><b>8.1</b> Projeção ortográfica</a><ul>
<li class="chapter" data-level="" data-path="ortho.html"><a href="ortho.html#translação-1"><i class="fa fa-check"></i>Translação</a></li>
<li class="chapter" data-level="" data-path="ortho.html"><a href="ortho.html#escala-e-reflexão"><i class="fa fa-check"></i>Escala e reflexão</a></li>
<li class="chapter" data-level="" data-path="ortho.html"><a href="ortho.html#matriz-de-projeção"><i class="fa fa-check"></i>Matriz de projeção</a></li>
</ul></li>
<li class="chapter" data-level="8.2" data-path="perspective.html"><a href="perspective.html"><i class="fa fa-check"></i><b>8.2</b> Projeção perspectiva</a><ul>
<li class="chapter" data-level="" data-path="perspective.html"><a href="perspective.html#matriz-de-projeção-1"><i class="fa fa-check"></i>Matriz de projeção</a></li>
</ul></li>
<li class="chapter" data-level="8.3" data-path="vtrackball1.html"><a href="vtrackball1.html"><i class="fa fa-check"></i><b>8.3</b> Trackball virtual</a><ul>
<li class="chapter" data-level="" data-path="vtrackball1.html"><a href="vtrackball1.html#rotação-em-torno-de-um-eixo-arbitrário"><i class="fa fa-check"></i>Rotação em torno de um eixo arbitrário</a></li>
</ul></li>
<li class="chapter" data-level="8.4" data-path="viewer1.html"><a href="viewer1.html"><i class="fa fa-check"></i><b>8.4</b> Visualizador 3D</a><ul>
<li class="chapter" data-level="" data-path="viewer1.html"><a href="viewer1.html#configuração-inicial-7"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="viewer1.html"><a href="viewer1.html#main.cpp-7"><i class="fa fa-check"></i>main.cpp</a></li>
<li class="chapter" data-level="" data-path="viewer1.html"><a href="viewer1.html#depth.vert"><i class="fa fa-check"></i>depth.vert</a></li>
<li class="chapter" data-level="" data-path="viewer1.html"><a href="viewer1.html#depth.frag"><i class="fa fa-check"></i>depth.frag</a></li>
<li class="chapter" data-level="" data-path="viewer1.html"><a href="viewer1.html#model.hpp"><i class="fa fa-check"></i>model.hpp</a></li>
<li class="chapter" data-level="" data-path="viewer1.html"><a href="viewer1.html#model.cpp"><i class="fa fa-check"></i>model.cpp</a></li>
<li class="chapter" data-level="" data-path="viewer1.html"><a href="viewer1.html#trackball.hpp"><i class="fa fa-check"></i>trackball.hpp</a></li>
<li class="chapter" data-level="" data-path="viewer1.html"><a href="viewer1.html#trackball.cpp"><i class="fa fa-check"></i>trackball.cpp</a></li>
<li class="chapter" data-level="" data-path="viewer1.html"><a href="viewer1.html#openglwindow.hpp-7"><i class="fa fa-check"></i>openglwindow.hpp</a></li>
<li class="chapter" data-level="" data-path="viewer1.html"><a href="viewer1.html#openglwindow.cpp-7"><i class="fa fa-check"></i>openglwindow.cpp</a></li>
</ul></li>
<li class="chapter" data-level="8.5" data-path="starfield.html"><a href="starfield.html"><i class="fa fa-check"></i><b>8.5</b> Efeito starfield</a><ul>
<li class="chapter" data-level="" data-path="starfield.html"><a href="starfield.html#configuração-inicial-8"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="starfield.html"><a href="starfield.html#main.cpp-8"><i class="fa fa-check"></i>main.cpp</a></li>
<li class="chapter" data-level="" data-path="starfield.html"><a href="starfield.html#depth.vert-1"><i class="fa fa-check"></i>depth.vert</a></li>
<li class="chapter" data-level="" data-path="starfield.html"><a href="starfield.html#depth.frag-1"><i class="fa fa-check"></i>depth.frag</a></li>
<li class="chapter" data-level="" data-path="starfield.html"><a href="starfield.html#openglwindow.hpp-8"><i class="fa fa-check"></i>openglwindow.hpp</a></li>
<li class="chapter" data-level="" data-path="starfield.html"><a href="starfield.html#openglwindow.cpp-8"><i class="fa fa-check"></i>openglwindow.cpp</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="9" data-path="lighting.html"><a href="lighting.html"><i class="fa fa-check"></i><b>9</b> Iluminação</a><ul>
<li class="chapter" data-level="9.1" data-path="renderingequation.html"><a href="renderingequation.html"><i class="fa fa-check"></i><b>9.1</b> Equação de renderização</a></li>
<li class="chapter" data-level="9.2" data-path="phongmodel.html"><a href="phongmodel.html"><i class="fa fa-check"></i><b>9.2</b> Modelo de reflexão de Phong</a><ul>
<li class="chapter" data-level="" data-path="phongmodel.html"><a href="phongmodel.html#reflexão-ambiente"><i class="fa fa-check"></i>Reflexão ambiente</a></li>
<li class="chapter" data-level="" data-path="phongmodel.html"><a href="phongmodel.html#reflexão-difusa"><i class="fa fa-check"></i>Reflexão difusa</a></li>
<li class="chapter" data-level="" data-path="phongmodel.html"><a href="phongmodel.html#reflexão-especular"><i class="fa fa-check"></i>Reflexão especular</a></li>
<li class="chapter" data-level="" data-path="phongmodel.html"><a href="phongmodel.html#modelo-completo"><i class="fa fa-check"></i>Modelo completo</a></li>
<li class="chapter" data-level="" data-path="phongmodel.html"><a href="phongmodel.html#iluminação-colorida"><i class="fa fa-check"></i>Iluminação colorida</a></li>
<li class="chapter" data-level="" data-path="phongmodel.html"><a href="phongmodel.html#fontes-de-luz"><i class="fa fa-check"></i>Fontes de luz</a></li>
</ul></li>
<li class="chapter" data-level="9.3" data-path="blinnphongmodel.html"><a href="blinnphongmodel.html"><i class="fa fa-check"></i><b>9.3</b> Modelo de Blinn–Phong</a></li>
<li class="chapter" data-level="9.4" data-path="shading.html"><a href="shading.html"><i class="fa fa-check"></i><b>9.4</b> Sombreamento</a><ul>
<li class="chapter" data-level="" data-path="shading.html"><a href="shading.html#flat"><i class="fa fa-check"></i>Flat</a></li>
<li class="chapter" data-level="" data-path="shading.html"><a href="shading.html#gouraud"><i class="fa fa-check"></i>Gouraud</a></li>
<li class="chapter" data-level="" data-path="shading.html"><a href="shading.html#phong"><i class="fa fa-check"></i>Phong</a></li>
</ul></li>
<li class="chapter" data-level="9.5" data-path="viewer2.html"><a href="viewer2.html"><i class="fa fa-check"></i><b>9.5</b> Normais como cores</a><ul>
<li class="chapter" data-level="" data-path="viewer2.html"><a href="viewer2.html#configuração-inicial-9"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="viewer2.html"><a href="viewer2.html#model.hpp-1"><i class="fa fa-check"></i>model.hpp</a></li>
<li class="chapter" data-level="" data-path="viewer2.html"><a href="viewer2.html#model.cpp-1"><i class="fa fa-check"></i>model.cpp</a></li>
<li class="chapter" data-level="" data-path="viewer2.html"><a href="viewer2.html#openglwindow.hpp-9"><i class="fa fa-check"></i>openglwindow.hpp</a></li>
<li class="chapter" data-level="" data-path="viewer2.html"><a href="viewer2.html#openglwindow.cpp-9"><i class="fa fa-check"></i>openglwindow.cpp</a></li>
<li class="chapter" data-level="" data-path="viewer2.html"><a href="viewer2.html#normal.frag"><i class="fa fa-check"></i>normal.frag</a></li>
<li class="chapter" data-level="" data-path="viewer2.html"><a href="viewer2.html#normal.vert"><i class="fa fa-check"></i>normal.vert</a></li>
</ul></li>
<li class="chapter" data-level="9.6" data-path="viewer3.html"><a href="viewer3.html"><i class="fa fa-check"></i><b>9.6</b> Iluminação na prática</a><ul>
<li class="chapter" data-level="" data-path="viewer3.html"><a href="viewer3.html#phong-com-sombreamento-de-gouraud"><i class="fa fa-check"></i>Phong com sombreamento de Gouraud</a></li>
<li class="chapter" data-level="" data-path="viewer3.html"><a href="viewer3.html#phong-com-sombreamento-de-phong"><i class="fa fa-check"></i>Phong com sombreamento de Phong</a></li>
<li class="chapter" data-level="" data-path="viewer3.html"><a href="viewer3.html#blinn-phong-com-sombreamento-de-phong"><i class="fa fa-check"></i>Blinn-Phong com sombreamento de Phong</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="10" data-path="texturing.html"><a href="texturing.html"><i class="fa fa-check"></i><b>10</b> Texturização</a><ul>
<li class="chapter" data-level="10.1" data-path="texmapping.html"><a href="texmapping.html"><i class="fa fa-check"></i><b>10.1</b> Mapeamento</a><ul>
<li class="chapter" data-level="" data-path="texmapping.html"><a href="texmapping.html#mapeamento-planar"><i class="fa fa-check"></i>Mapeamento planar</a></li>
<li class="chapter" data-level="" data-path="texmapping.html"><a href="texmapping.html#mapeamento-cilíndrico"><i class="fa fa-check"></i>Mapeamento cilíndrico</a></li>
<li class="chapter" data-level="" data-path="texmapping.html"><a href="texmapping.html#mapeamento-esférico"><i class="fa fa-check"></i>Mapeamento esférico</a></li>
<li class="chapter" data-level="" data-path="texmapping.html"><a href="texmapping.html#mapeamento-uv-unwrap"><i class="fa fa-check"></i>Mapeamento UV unwrap</a></li>
</ul></li>
<li class="chapter" data-level="10.2" data-path="texwrapping.html"><a href="texwrapping.html"><i class="fa fa-check"></i><b>10.2</b> Empacotamento</a></li>
<li class="chapter" data-level="10.3" data-path="texfiltering.html"><a href="texfiltering.html"><i class="fa fa-check"></i><b>10.3</b> Filtragem</a><ul>
<li class="chapter" data-level="" data-path="texfiltering.html"><a href="texfiltering.html#magnificação"><i class="fa fa-check"></i>Magnificação</a></li>
<li class="chapter" data-level="" data-path="texfiltering.html"><a href="texfiltering.html#minificação"><i class="fa fa-check"></i>Minificação</a></li>
</ul></li>
<li class="chapter" data-level="10.4" data-path="viewer4.html"><a href="viewer4.html"><i class="fa fa-check"></i><b>10.4</b> Texturização na prática</a><ul>
<li class="chapter" data-level="" data-path="viewer4.html"><a href="viewer4.html#gerando-texturas"><i class="fa fa-check"></i>Gerando texturas</a></li>
<li class="chapter" data-level="" data-path="viewer4.html"><a href="viewer4.html#carregando-modelos-com-textura"><i class="fa fa-check"></i>Carregando modelos com textura</a></li>
<li class="chapter" data-level="" data-path="viewer4.html"><a href="viewer4.html#renderizando"><i class="fa fa-check"></i>Renderizando</a></li>
</ul></li>
<li class="chapter" data-level="10.5" data-path="normalmapping.html"><a href="normalmapping.html"><i class="fa fa-check"></i><b>10.5</b> Mapeamento de normais</a><ul>
<li class="chapter" data-level="" data-path="normalmapping.html"><a href="normalmapping.html#espaço-tangente"><i class="fa fa-check"></i>Espaço tangente</a></li>
<li class="chapter" data-level="" data-path="normalmapping.html"><a href="normalmapping.html#transformação-para-o-espaço-tangente"><i class="fa fa-check"></i>Transformação para o espaço tangente</a></li>
<li class="chapter" data-level="" data-path="normalmapping.html"><a href="normalmapping.html#vetor-tangente-e-bitangente"><i class="fa fa-check"></i>Vetor tangente e bitangente</a></li>
<li class="chapter" data-level="" data-path="normalmapping.html"><a href="normalmapping.html#mapeamento-de-normais-na-prática"><i class="fa fa-check"></i>Mapeamento de normais na prática</a></li>
</ul></li>
<li class="chapter" data-level="10.6" data-path="envmapping.html"><a href="envmapping.html"><i class="fa fa-check"></i><b>10.6</b> Mapeamento de ambiente</a><ul>
<li class="chapter" data-level="" data-path="envmapping.html"><a href="envmapping.html#mapeamento-esférico-1"><i class="fa fa-check"></i>Mapeamento esférico</a></li>
<li class="chapter" data-level="" data-path="envmapping.html"><a href="envmapping.html#mapeamento-cúbico"><i class="fa fa-check"></i>Mapeamento cúbico</a></li>
<li class="chapter" data-level="" data-path="envmapping.html"><a href="envmapping.html#mapeamento-de-ambiente-na-prática"><i class="fa fa-check"></i>Mapeamento de ambiente na prática</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="atividades-entregues.html"><a href="atividades-entregues.html"><i class="fa fa-check"></i>Atividades entregues</a><ul>
<li class="chapter" data-level="" data-path="atividade-1.html"><a href="atividade-1.html"><i class="fa fa-check"></i>Atividade 1</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="referências.html"><a href="referências.html"><i class="fa fa-check"></i>Referências</a></li>
<li class="divider"></li>
<li>
<a href="mailto:harlen.batagelo@ufabc.edu.br" target="blank">Harlen Batagelo</a>
</li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">MCTA008-17 Computação Gráfica</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="regularpolygons" class="section level2">
<h2><span class="header-section-number">5.1</span> Polígonos regulares</h2>
<p>Este projeto é um aprimoramento do projeto <code>coloredtriangles</code> da seção <a href="coloredtriangles.html#coloredtriangles">4.4</a>. No lugar de desenharmos triângulos (<code>GL_TRIANGLES</code>), desenharemos polígonos regulares 2D formados por leques de triângulos (<code>GL_TRIANGLE_FAN</code>). Para cada quadro de exibição, será renderizado um polígono regular colorido em uma posição aleatória do viewport. O número de lados de cada polígono também será escolhido aleatoriamente. A aplicação ficará como a seguir:</p>
<iframe
  src="https://hbatagelo.github.io/abcgapps/regularpolygons/index.html"
  frameborder="0" allowfullscreen="true" allowtransparency="true" emscriptenheight="735"
  ></iframe>
<div id="configuração-inicial-3" class="section level3 unnumbered">
<h3>Configuração inicial</h3>
<p>A configuração inicial é a mesma dos projetos anteriores. Apenas mude o nome do projeto para <code>regularpolygons</code> e inclua a linha <code>add_subdirectory(regularpolygons)</code> em <code>abcg/examples/CMakeLists.txt</code>.</p>
<p>O arquivo <code>abcg/examples/regularpolygons/CMakeLists.txt</code> ficará assim:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb125-1"><a href="regularpolygons.html#cb125-1"></a><span class="kw">project</span>(regularpolygons)</span>
<span id="cb125-2"><a href="regularpolygons.html#cb125-2"></a><span class="kw">add_executable</span>(<span class="dv">${PROJECT_NAME}</span> main.cpp openglwindow.cpp)</span>
<span id="cb125-3"><a href="regularpolygons.html#cb125-3"></a><span class="fu">enable_abcg</span>(<span class="dv">${PROJECT_NAME}</span>)</span></code></pre></div>
<p>Este projeto também terá os arquivos <code>main.cpp</code>, <code>openglwindow.cpp</code> e <code>openglwindow.hpp</code>.</p>
</div>
<div id="main.cpp-3" class="section level3 unnumbered">
<h3>main.cpp</h3>
<p>O conteúdo de <code>main.cpp</code> é praticamente idêntico ao do projeto <code>coloredtriangles</code>:</p>
<div class="sourceCode" id="cb126" startFrom="1"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb126-1"><a href="regularpolygons.html#cb126-1"></a><span class="pp">#include </span><span class="im">&lt;fmt/core.h&gt;</span></span>
<span id="cb126-2"><a href="regularpolygons.html#cb126-2"></a></span>
<span id="cb126-3"><a href="regularpolygons.html#cb126-3"></a><span class="pp">#include </span><span class="im">&quot;abcg.hpp&quot;</span></span>
<span id="cb126-4"><a href="regularpolygons.html#cb126-4"></a><span class="pp">#include </span><span class="im">&quot;openglwindow.hpp&quot;</span></span>
<span id="cb126-5"><a href="regularpolygons.html#cb126-5"></a></span>
<span id="cb126-6"><a href="regularpolygons.html#cb126-6"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {</span>
<span id="cb126-7"><a href="regularpolygons.html#cb126-7"></a>  <span class="cf">try</span> {</span>
<span id="cb126-8"><a href="regularpolygons.html#cb126-8"></a>    <span class="co">// Create application instance</span></span>
<span id="cb126-9"><a href="regularpolygons.html#cb126-9"></a>    abcg::Application app(argc, argv);</span>
<span id="cb126-10"><a href="regularpolygons.html#cb126-10"></a></span>
<span id="cb126-11"><a href="regularpolygons.html#cb126-11"></a>    <span class="co">// Create OpenGL window</span></span>
<span id="cb126-12"><a href="regularpolygons.html#cb126-12"></a>    <span class="kw">auto</span> window{<span class="bu">std::</span>make_unique&lt;OpenGLWindow&gt;()};</span>
<span id="cb126-13"><a href="regularpolygons.html#cb126-13"></a>    window-&gt;setOpenGLSettings(</span>
<span id="cb126-14"><a href="regularpolygons.html#cb126-14"></a>        {.samples = <span class="dv">2</span>, .preserveWebGLDrawingBuffer = <span class="kw">true</span>});</span>
<span id="cb126-15"><a href="regularpolygons.html#cb126-15"></a>    window-&gt;setWindowSettings(</span>
<span id="cb126-16"><a href="regularpolygons.html#cb126-16"></a>        {.width = <span class="dv">600</span>, .height = <span class="dv">600</span>, .title = <span class="st">&quot;Regular Polygons&quot;</span>});</span>
<span id="cb126-17"><a href="regularpolygons.html#cb126-17"></a></span>
<span id="cb126-18"><a href="regularpolygons.html#cb126-18"></a>    <span class="co">// Run application</span></span>
<span id="cb126-19"><a href="regularpolygons.html#cb126-19"></a>    app.run(window);</span>
<span id="cb126-20"><a href="regularpolygons.html#cb126-20"></a>  } <span class="cf">catch</span> (abcg::Exception &amp;exception) {</span>
<span id="cb126-21"><a href="regularpolygons.html#cb126-21"></a>    fmt::print(stderr, <span class="st">&quot;{}</span><span class="sc">\n</span><span class="st">&quot;</span>, exception.what());</span>
<span id="cb126-22"><a href="regularpolygons.html#cb126-22"></a>    <span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb126-23"><a href="regularpolygons.html#cb126-23"></a>  }</span>
<span id="cb126-24"><a href="regularpolygons.html#cb126-24"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb126-25"><a href="regularpolygons.html#cb126-25"></a>}</span></code></pre></div>
</div>
<div id="openglwindow.hpp-3" class="section level3 unnumbered">
<h3>openglwindow.hpp</h3>
<p>Aqui também há poucas mudanças em relação ao projeto anterior:</p>
<div class="sourceCode" id="cb127" startFrom="1"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb127-1"><a href="regularpolygons.html#cb127-1"></a><span class="pp">#ifndef OPENGLWINDOW_HPP_</span></span>
<span id="cb127-2"><a href="regularpolygons.html#cb127-2"></a><span class="pp">#define OPENGLWINDOW_HPP_</span></span>
<span id="cb127-3"><a href="regularpolygons.html#cb127-3"></a></span>
<span id="cb127-4"><a href="regularpolygons.html#cb127-4"></a><span class="pp">#include </span><span class="im">&lt;random&gt;</span></span>
<span id="cb127-5"><a href="regularpolygons.html#cb127-5"></a></span>
<span id="cb127-6"><a href="regularpolygons.html#cb127-6"></a><span class="pp">#include </span><span class="im">&quot;abcg.hpp&quot;</span></span>
<span id="cb127-7"><a href="regularpolygons.html#cb127-7"></a></span>
<span id="cb127-8"><a href="regularpolygons.html#cb127-8"></a><span class="kw">class</span> OpenGLWindow : <span class="kw">public</span> abcg::OpenGLWindow {</span>
<span id="cb127-9"><a href="regularpolygons.html#cb127-9"></a> <span class="kw">protected</span>:</span>
<span id="cb127-10"><a href="regularpolygons.html#cb127-10"></a>  <span class="dt">void</span> initializeGL() <span class="kw">override</span>;</span>
<span id="cb127-11"><a href="regularpolygons.html#cb127-11"></a>  <span class="dt">void</span> paintGL() <span class="kw">override</span>;</span>
<span id="cb127-12"><a href="regularpolygons.html#cb127-12"></a>  <span class="dt">void</span> paintUI() <span class="kw">override</span>;</span>
<span id="cb127-13"><a href="regularpolygons.html#cb127-13"></a>  <span class="dt">void</span> resizeGL(<span class="dt">int</span> width, <span class="dt">int</span> height) <span class="kw">override</span>;</span>
<span id="cb127-14"><a href="regularpolygons.html#cb127-14"></a>  <span class="dt">void</span> terminateGL() <span class="kw">override</span>;</span>
<span id="cb127-15"><a href="regularpolygons.html#cb127-15"></a></span>
<span id="cb127-16"><a href="regularpolygons.html#cb127-16"></a> <span class="kw">private</span>:</span>
<span id="cb127-17"><a href="regularpolygons.html#cb127-17"></a>  GLuint <span class="va">m_vao</span>{};</span>
<span id="cb127-18"><a href="regularpolygons.html#cb127-18"></a>  GLuint <span class="va">m_vboPositions</span>{};</span>
<span id="cb127-19"><a href="regularpolygons.html#cb127-19"></a>  GLuint <span class="va">m_vboColors</span>{};</span>
<span id="cb127-20"><a href="regularpolygons.html#cb127-20"></a>  GLuint <span class="va">m_program</span>{};</span>
<span id="cb127-21"><a href="regularpolygons.html#cb127-21"></a></span>
<span id="cb127-22"><a href="regularpolygons.html#cb127-22"></a>  <span class="dt">int</span> <span class="va">m_viewportWidth</span>{};</span>
<span id="cb127-23"><a href="regularpolygons.html#cb127-23"></a>  <span class="dt">int</span> <span class="va">m_viewportHeight</span>{};</span>
<span id="cb127-24"><a href="regularpolygons.html#cb127-24"></a></span>
<span id="cb127-25"><a href="regularpolygons.html#cb127-25"></a>  <span class="bu">std::</span>default_random_engine <span class="va">m_randomEngine</span>;</span>
<span id="cb127-26"><a href="regularpolygons.html#cb127-26"></a></span>
<span id="cb127-27"><a href="regularpolygons.html#cb127-27"></a>  <span class="dt">int</span> <span class="va">m_delay</span>{<span class="dv">200</span>};</span>
<span id="cb127-28"><a href="regularpolygons.html#cb127-28"></a>  abcg::ElapsedTimer <span class="va">m_elapsedTimer</span>;</span>
<span id="cb127-29"><a href="regularpolygons.html#cb127-29"></a></span>
<span id="cb127-30"><a href="regularpolygons.html#cb127-30"></a>  <span class="dt">void</span> setupModel(<span class="dt">int</span> sides);</span>
<span id="cb127-31"><a href="regularpolygons.html#cb127-31"></a>};</span>
<span id="cb127-32"><a href="regularpolygons.html#cb127-32"></a></span>
<span id="cb127-33"><a href="regularpolygons.html#cb127-33"></a><span class="pp">#endif</span></span></code></pre></div>
<p>Observe que há novamente dois VBOs: um para a posição e outro para a cor dos vértices (linhas 18 e 19).</p>
<p>Na linha 27, a variável <code>m_delay</code> é utilizada para especificar o intervalo de tempo, em milissegundos, entre a renderização dos polígonos.</p>
<p>Na linha 28, <code>m_elapsedTimer</code>, da classe <code>abcg::ElapsedTimer</code>, é um temporizador simples usando funções da biblioteca <code>std::chrono</code>. A contagem de tempo inicia quando o objeto é criado. Só há dois métodos disponíveis:</p>
<ul>
<li><code>double abcg::ElapsedTimer::elapsed()</code> retorna o tempo, em segundos, desde a criação do objeto, ou desde a última chamada a <code>abcg::ElapsedTimer::restart()</code>;</li>
<li><code>double abcg::ElapsedTimer::restart()</code> reinicia a contagem de tempo.</li>
</ul>
<p>Usaremos <code>m_elapsedTimer</code> junto com <code>m_delay</code> para definir a frequência de desenho dos polígonos.</p>
</div>
<div id="openglwindow.cpp-3" class="section level3 unnumbered">
<h3>openglwindow.cpp</h3>
<p>A definição de <code>OpenGLWindow::initializeGL</code> é a mesma do projeto <code>coloredtriangles</code>. Apenas o conteúdo do vertex shader será modificado. A definição completa ficará assim:</p>
<div class="sourceCode" id="cb128" startFrom="9"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 8;"><span id="cb128-9"><a href="regularpolygons.html#cb128-9"></a><span class="dt">void</span> OpenGLWindow::initializeGL() {</span>
<span id="cb128-10"><a href="regularpolygons.html#cb128-10"></a>  <span class="at">const</span> <span class="kw">auto</span> *vertexShader{<span class="st">R&quot;gl(</span></span>
<span id="cb128-11"><a href="regularpolygons.html#cb128-11"></a><span class="st">    #version 410</span></span>
<span id="cb128-12"><a href="regularpolygons.html#cb128-12"></a></span>
<span id="cb128-13"><a href="regularpolygons.html#cb128-13"></a><span class="st">    layout(location = 0) in vec2 inPosition;</span></span>
<span id="cb128-14"><a href="regularpolygons.html#cb128-14"></a><span class="st">    layout(location = 1) in vec4 inColor;</span></span>
<span id="cb128-15"><a href="regularpolygons.html#cb128-15"></a></span>
<span id="cb128-16"><a href="regularpolygons.html#cb128-16"></a><span class="st">    uniform vec2 translation;</span></span>
<span id="cb128-17"><a href="regularpolygons.html#cb128-17"></a><span class="st">    uniform float scale;</span></span>
<span id="cb128-18"><a href="regularpolygons.html#cb128-18"></a></span>
<span id="cb128-19"><a href="regularpolygons.html#cb128-19"></a><span class="st">    out vec4 fragColor;</span></span>
<span id="cb128-20"><a href="regularpolygons.html#cb128-20"></a></span>
<span id="cb128-21"><a href="regularpolygons.html#cb128-21"></a><span class="st">    void main() {</span></span>
<span id="cb128-22"><a href="regularpolygons.html#cb128-22"></a><span class="st">      vec2 newPosition = inPosition * scale + translation;</span></span>
<span id="cb128-23"><a href="regularpolygons.html#cb128-23"></a><span class="st">      gl_Position = vec4(newPosition, 0, 1);</span></span>
<span id="cb128-24"><a href="regularpolygons.html#cb128-24"></a><span class="st">      fragColor = inColor;</span></span>
<span id="cb128-25"><a href="regularpolygons.html#cb128-25"></a><span class="st">    }</span></span>
<span id="cb128-26"><a href="regularpolygons.html#cb128-26"></a><span class="st">  )gl&quot;};</span></span>
<span id="cb128-27"><a href="regularpolygons.html#cb128-27"></a></span>
<span id="cb128-28"><a href="regularpolygons.html#cb128-28"></a><span class="st">  const auto *fragmentShader{R&quot;gl(</span></span>
<span id="cb128-29"><a href="regularpolygons.html#cb128-29"></a><span class="st">    #version 410</span></span>
<span id="cb128-30"><a href="regularpolygons.html#cb128-30"></a></span>
<span id="cb128-31"><a href="regularpolygons.html#cb128-31"></a><span class="st">    in vec4 fragColor;</span></span>
<span id="cb128-32"><a href="regularpolygons.html#cb128-32"></a></span>
<span id="cb128-33"><a href="regularpolygons.html#cb128-33"></a><span class="st">    out vec4 outColor;</span></span>
<span id="cb128-34"><a href="regularpolygons.html#cb128-34"></a></span>
<span id="cb128-35"><a href="regularpolygons.html#cb128-35"></a><span class="st">    void main() { outColor = fragColor; }</span></span>
<span id="cb128-36"><a href="regularpolygons.html#cb128-36"></a><span class="st">  )gl&quot;};</span></span>
<span id="cb128-37"><a href="regularpolygons.html#cb128-37"></a></span>
<span id="cb128-38"><a href="regularpolygons.html#cb128-38"></a><span class="st">  // Create shader program</span></span>
<span id="cb128-39"><a href="regularpolygons.html#cb128-39"></a><span class="st">  m_program = createProgramFromString(vertexShader, fragmentShader);</span></span>
<span id="cb128-40"><a href="regularpolygons.html#cb128-40"></a></span>
<span id="cb128-41"><a href="regularpolygons.html#cb128-41"></a><span class="st">  // Clear window</span></span>
<span id="cb128-42"><a href="regularpolygons.html#cb128-42"></a><span class="st">  glClearColor(0, 0, 0, 1);</span></span>
<span id="cb128-43"><a href="regularpolygons.html#cb128-43"></a><span class="st">  glClear(GL_COLOR_BUFFER_BIT);</span></span>
<span id="cb128-44"><a href="regularpolygons.html#cb128-44"></a></span>
<span id="cb128-45"><a href="regularpolygons.html#cb128-45"></a><span class="st">  // Start pseudo-random number generator</span></span>
<span id="cb128-46"><a href="regularpolygons.html#cb128-46"></a><span class="st">  auto seed{std::chrono::steady_clock::now().time_since_epoch().count()};</span></span>
<span id="cb128-47"><a href="regularpolygons.html#cb128-47"></a><span class="st">  m_randomEngine.seed(seed);</span></span>
<span id="cb128-48"><a href="regularpolygons.html#cb128-48"></a><span class="st">}</span></span></code></pre></div>
<p>Compare o código do vertex shader na string <code>vertexShader</code> com o vertex shader do projeto anterior. No projeto anterior (<code>coloredtriangles</code>), o vertex shader estava assim:</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb129-1"><a href="regularpolygons.html#cb129-1"></a><span class="pp">#version 410</span></span>
<span id="cb129-2"><a href="regularpolygons.html#cb129-2"></a></span>
<span id="cb129-3"><a href="regularpolygons.html#cb129-3"></a><span class="kw">layout</span>(<span class="dt">location</span> = <span class="dv">0</span>) <span class="dt">in</span> <span class="dt">vec2</span> inPosition;</span>
<span id="cb129-4"><a href="regularpolygons.html#cb129-4"></a><span class="kw">layout</span>(<span class="dt">location</span> = <span class="dv">1</span>) <span class="dt">in</span> <span class="dt">vec4</span> inColor;</span>
<span id="cb129-5"><a href="regularpolygons.html#cb129-5"></a></span>
<span id="cb129-6"><a href="regularpolygons.html#cb129-6"></a><span class="dt">out</span> <span class="dt">vec4</span> fragColor;</span>
<span id="cb129-7"><a href="regularpolygons.html#cb129-7"></a></span>
<span id="cb129-8"><a href="regularpolygons.html#cb129-8"></a><span class="dt">void</span> <span class="fu">main</span>() {</span>
<span id="cb129-9"><a href="regularpolygons.html#cb129-9"></a>  <span class="bu">gl_Position</span> = <span class="dt">vec4</span>(inPosition, <span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb129-10"><a href="regularpolygons.html#cb129-10"></a>  fragColor = inColor;</span>
<span id="cb129-11"><a href="regularpolygons.html#cb129-11"></a>}</span></code></pre></div>
<p>Agora o vertex shader ficará assim:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb130-1"><a href="regularpolygons.html#cb130-1"></a><span class="pp">#version 410</span></span>
<span id="cb130-2"><a href="regularpolygons.html#cb130-2"></a></span>
<span id="cb130-3"><a href="regularpolygons.html#cb130-3"></a><span class="kw">layout</span>(<span class="dt">location</span> = <span class="dv">0</span>) <span class="dt">in</span> <span class="dt">vec2</span> inPosition;</span>
<span id="cb130-4"><a href="regularpolygons.html#cb130-4"></a><span class="kw">layout</span>(<span class="dt">location</span> = <span class="dv">1</span>) <span class="dt">in</span> <span class="dt">vec4</span> inColor;</span>
<span id="cb130-5"><a href="regularpolygons.html#cb130-5"></a></span>
<span id="cb130-6"><a href="regularpolygons.html#cb130-6"></a><span class="kw">uniform</span> <span class="dt">vec2</span> translation;</span>
<span id="cb130-7"><a href="regularpolygons.html#cb130-7"></a><span class="kw">uniform</span> <span class="dt">float</span> scale;</span>
<span id="cb130-8"><a href="regularpolygons.html#cb130-8"></a></span>
<span id="cb130-9"><a href="regularpolygons.html#cb130-9"></a><span class="dt">out</span> <span class="dt">vec4</span> fragColor;</span>
<span id="cb130-10"><a href="regularpolygons.html#cb130-10"></a></span>
<span id="cb130-11"><a href="regularpolygons.html#cb130-11"></a><span class="dt">void</span> <span class="fu">main</span>() {</span>
<span id="cb130-12"><a href="regularpolygons.html#cb130-12"></a>  <span class="dt">vec2</span> newPosition = inPosition * scale + translation;</span>
<span id="cb130-13"><a href="regularpolygons.html#cb130-13"></a>  <span class="bu">gl_Position</span> = <span class="dt">vec4</span>(newPosition, <span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb130-14"><a href="regularpolygons.html#cb130-14"></a>  fragColor = inColor;</span>
<span id="cb130-15"><a href="regularpolygons.html#cb130-15"></a>}</span></code></pre></div>
<p>A principal mudança é o uso de duas variáveis uniformes, identificadas pela palavra-chave <code>uniform</code>. São elas:</p>
<ul>
<li><code>translation</code>: um fator de translação (deslocamento) da geometria;</li>
<li><code>scale</code>: um fator de escala da geometria.</li>
</ul>
<p>O conteúdo de <code>translation</code> e <code>scale</code> é definido em <code>paintGL</code> antes de cada renderização. Variáveis uniformes são variáveis globais do shader que não mudam de valor de um vértice para outro, ao contrário do que ocorre com as variáveis <code>inPosition</code> e <code>inColor</code>.</p>
<p>Observe o conteúdo da função <code>main</code>:</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb131-1"><a href="regularpolygons.html#cb131-1"></a><span class="dt">void</span> <span class="fu">main</span>() {</span>
<span id="cb131-2"><a href="regularpolygons.html#cb131-2"></a>  <span class="dt">vec2</span> newPosition = inPosition * scale + translation;</span>
<span id="cb131-3"><a href="regularpolygons.html#cb131-3"></a>  <span class="bu">gl_Position</span> = <span class="dt">vec4</span>(newPosition, <span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb131-4"><a href="regularpolygons.html#cb131-4"></a>  fragColor = inColor;</span>
<span id="cb131-5"><a href="regularpolygons.html#cb131-5"></a>}</span></code></pre></div>
<p>A posição original do vértice (<code>inPosition</code>) é multiplicada por <code>scale</code> e somada com <code>translation</code> para gerar uma nova posição (<code>newPosition</code>), que é a posição final do vértice passada para <code>gl_Position</code>.</p>
<p>Na expressão <code>inPosition * scale + translation</code>, <code>inPosition * scale</code> resulta na aplicação do fator de escala nas coordenadas <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span> do vértice. Como isso é feito para cada vértice da geometria, o resultado será a mudança do tamanho do objeto. Se o fator de escala for 1, não haverá mudança de escala. Se for 0.5, o tamanho do objeto será reduzido pela metade em <span class="math inline">\(x\)</span> e em <span class="math inline">\(y\)</span>. Se for 2.0, o tamanho será dobrado em <span class="math inline">\(x\)</span> e em <span class="math inline">\(y\)</span>.</p>
<p>O resultado de <code>inPosition * scale</code> é somado com <code>translation</code>. Isso significa que, após a mudança de escala, a geometria será deslocada pelas coordenadas <span class="math inline">\((x,y)\)</span> da translação.</p>
<p>Ao aplicar a escala e a translação do vertex shader, podemos usar um mesmo VBO para renderizar o objeto em posições e escalas diferentes, como mostra a figura <a href="regularpolygons.html#fig:regularpolygons1">5.1</a>:</p>
<div class="figure" style="text-align: center"><span id="fig:regularpolygons1"></span>
<img src="images/05_regularpolygons1.svg" alt="Resultado da transformação dos vértices de um triângulo usando diferentes fatores de escala e translação." width="100%" />
<p class="caption">
Figura 5.1: Resultado da transformação dos vértices de um triângulo usando diferentes fatores de escala e translação.
</p>
</div>
<div class="infobox">
<svg style="height:1.4em;fill:#555;" viewBox="0 0 512 512">
<path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/>
</svg>
<div class="infoboxtitle">
Observação
</div>
<p>O uso de variáveis uniformes e transformações geométricas no vertex shader pode reduzir em muito o consumo de memória dos dados gráficos.</p>
<p>Suponha que queremos renderizar uma cena estilo <a href="https://www.minecraft.net/">Minecraft</a> composta por 100.000 cubos. A estratégia mais ingênua para renderizar essa cena é criar um único VBO contendo os vértices dos 100.000 cubos. Se usarmos <code>GL_TRIANGLES</code>, cada lado do cubo terá de ser renderizado como 2 triângulos, isto é, precisaremos de 6 vértices. Como um cubo tem 6 lados, teremos então 36 vértices por cubo. Logo, nosso VBO de 100.000 cubos terá 3.600.000 vértices<a href="#fn22" class="footnote-ref" id="fnref22"><sup>22</sup></a>.</p>
<p>Ao usar variáveis uniformes, podemos criar um VBO para apenas um cubo e renderizar esse cubo 100.000 vezes, cada um com um fator de escala e translação diferente. No fim, o número de vértices processados será igual, mas o uso de memória terá uma redução de 5 ordens de magnitude!</p>
</div>
<p>Vamos agora à definição de <code>OpenGLWindow::paintGL()</code>:</p>
<div class="sourceCode" id="cb132" startFrom="50"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 49;"><span id="cb132-50"><a href="regularpolygons.html#cb132-50"></a><span class="dt">void</span> OpenGLWindow::paintGL() {</span>
<span id="cb132-51"><a href="regularpolygons.html#cb132-51"></a>  <span class="co">// Check whether to render the next polygon</span></span>
<span id="cb132-52"><a href="regularpolygons.html#cb132-52"></a>  <span class="cf">if</span> (<span class="va">m_elapsedTimer</span>.elapsed() &lt; <span class="va">m_delay</span> / <span class="fl">1000.0</span>) <span class="cf">return</span>;</span>
<span id="cb132-53"><a href="regularpolygons.html#cb132-53"></a>  <span class="va">m_elapsedTimer</span>.restart();</span>
<span id="cb132-54"><a href="regularpolygons.html#cb132-54"></a></span>
<span id="cb132-55"><a href="regularpolygons.html#cb132-55"></a>  <span class="co">// Create a regular polygon with a number of sides in the range [3;20]</span></span>
<span id="cb132-56"><a href="regularpolygons.html#cb132-56"></a>  <span class="bu">std::</span>uniform_int_distribution&lt;<span class="dt">int</span>&gt; intDist(<span class="dv">3</span>, <span class="dv">20</span>);</span>
<span id="cb132-57"><a href="regularpolygons.html#cb132-57"></a>  <span class="kw">auto</span> sides{intDist(<span class="va">m_randomEngine</span>)};</span>
<span id="cb132-58"><a href="regularpolygons.html#cb132-58"></a>  setupModel(sides);</span>
<span id="cb132-59"><a href="regularpolygons.html#cb132-59"></a></span>
<span id="cb132-60"><a href="regularpolygons.html#cb132-60"></a>  glViewport(<span class="dv">0</span>, <span class="dv">0</span>, <span class="va">m_viewportWidth</span>, <span class="va">m_viewportHeight</span>);</span>
<span id="cb132-61"><a href="regularpolygons.html#cb132-61"></a></span>
<span id="cb132-62"><a href="regularpolygons.html#cb132-62"></a>  glUseProgram(<span class="va">m_program</span>);</span>
<span id="cb132-63"><a href="regularpolygons.html#cb132-63"></a></span>
<span id="cb132-64"><a href="regularpolygons.html#cb132-64"></a>  <span class="co">// Choose a random xy position from (-1, -1) to (1, 1)</span></span>
<span id="cb132-65"><a href="regularpolygons.html#cb132-65"></a>  <span class="bu">std::</span>uniform_real_distribution&lt;<span class="dt">float</span>&gt; rd1(-<span class="fl">1.0</span><span class="bu">f</span>, <span class="fl">1.0</span><span class="bu">f</span>);</span>
<span id="cb132-66"><a href="regularpolygons.html#cb132-66"></a>  glm::vec2 translation{rd1(<span class="va">m_randomEngine</span>), rd1(<span class="va">m_randomEngine</span>)};</span>
<span id="cb132-67"><a href="regularpolygons.html#cb132-67"></a>  GLint translationLocation{glGetUniformLocation(<span class="va">m_program</span>, <span class="st">&quot;translation&quot;</span>)};</span>
<span id="cb132-68"><a href="regularpolygons.html#cb132-68"></a>  glUniform2fv(translationLocation, <span class="dv">1</span>, &amp;translation.x);</span>
<span id="cb132-69"><a href="regularpolygons.html#cb132-69"></a></span>
<span id="cb132-70"><a href="regularpolygons.html#cb132-70"></a>  <span class="co">// Choose a random scale factor (1% to 25%)</span></span>
<span id="cb132-71"><a href="regularpolygons.html#cb132-71"></a>  <span class="bu">std::</span>uniform_real_distribution&lt;<span class="dt">float</span>&gt; rd2(<span class="fl">0.01</span><span class="bu">f</span>, <span class="fl">0.25</span><span class="bu">f</span>);</span>
<span id="cb132-72"><a href="regularpolygons.html#cb132-72"></a>  <span class="kw">auto</span> scale{rd2(<span class="va">m_randomEngine</span>)};</span>
<span id="cb132-73"><a href="regularpolygons.html#cb132-73"></a>  GLint scaleLocation{glGetUniformLocation(<span class="va">m_program</span>, <span class="st">&quot;scale&quot;</span>)};</span>
<span id="cb132-74"><a href="regularpolygons.html#cb132-74"></a>  glUniform1f(scaleLocation, scale);</span>
<span id="cb132-75"><a href="regularpolygons.html#cb132-75"></a></span>
<span id="cb132-76"><a href="regularpolygons.html#cb132-76"></a>  <span class="co">// Render</span></span>
<span id="cb132-77"><a href="regularpolygons.html#cb132-77"></a>  glBindVertexArray(<span class="va">m_vao</span>);</span>
<span id="cb132-78"><a href="regularpolygons.html#cb132-78"></a>  glDrawArrays(GL_TRIANGLE_FAN, <span class="dv">0</span>, sides + <span class="dv">2</span>);</span>
<span id="cb132-79"><a href="regularpolygons.html#cb132-79"></a>  glBindVertexArray(<span class="dv">0</span>);</span>
<span id="cb132-80"><a href="regularpolygons.html#cb132-80"></a></span>
<span id="cb132-81"><a href="regularpolygons.html#cb132-81"></a>  glUseProgram(<span class="dv">0</span>);</span>
<span id="cb132-82"><a href="regularpolygons.html#cb132-82"></a>}</span></code></pre></div>
<p>Na linha 52, o tempo contado por <code>m_elapsedTimer</code> é comparado com <code>m_delay</code>. Se o tempo ainda não atingiu <code>m_delay</code>, a função retorna. Caso contrário, o temporizador é reiniciado na linha 53 e o método continua nas linhas seguintes.</p>
<p>Na linha 58, <code>setupModel(sides)</code> é chamado para criar o VBO de um polígono regular de <code>sides</code> lados. O número de lados é escolhido aletoriamente do intervalo <span class="math inline">\([3,20]\)</span>.</p>
<p>Nas linhas 64 a 74 são definidos os valores das variáveis uniformes do shader:</p>
<div class="sourceCode" id="cb133" startFrom="64"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 63;"><span id="cb133-64"><a href="regularpolygons.html#cb133-64"></a>  <span class="co">// Choose a random xy position from (-1, -1) to (1, 1)</span></span>
<span id="cb133-65"><a href="regularpolygons.html#cb133-65"></a>  <span class="bu">std::</span>uniform_real_distribution&lt;<span class="dt">float</span>&gt; rd1(-<span class="fl">1.0</span><span class="bu">f</span>, <span class="fl">1.0</span><span class="bu">f</span>);</span>
<span id="cb133-66"><a href="regularpolygons.html#cb133-66"></a>  glm::vec2 translation{rd1(<span class="va">m_randomEngine</span>), rd1(<span class="va">m_randomEngine</span>)};</span>
<span id="cb133-67"><a href="regularpolygons.html#cb133-67"></a>  GLint translationLocation{glGetUniformLocation(<span class="va">m_program</span>, <span class="st">&quot;translation&quot;</span>)};</span>
<span id="cb133-68"><a href="regularpolygons.html#cb133-68"></a>  glUniform2fv(translationLocation, <span class="dv">1</span>, &amp;translation.x);</span>
<span id="cb133-69"><a href="regularpolygons.html#cb133-69"></a></span>
<span id="cb133-70"><a href="regularpolygons.html#cb133-70"></a>  <span class="co">// Choose a random scale factor (1% to 25%)</span></span>
<span id="cb133-71"><a href="regularpolygons.html#cb133-71"></a>  <span class="bu">std::</span>uniform_real_distribution&lt;<span class="dt">float</span>&gt; rd2(<span class="fl">0.01</span><span class="bu">f</span>, <span class="fl">0.25</span><span class="bu">f</span>);</span>
<span id="cb133-72"><a href="regularpolygons.html#cb133-72"></a>  <span class="kw">auto</span> scale{rd2(<span class="va">m_randomEngine</span>)};</span>
<span id="cb133-73"><a href="regularpolygons.html#cb133-73"></a>  GLint scaleLocation{glGetUniformLocation(<span class="va">m_program</span>, <span class="st">&quot;scale&quot;</span>)};</span>
<span id="cb133-74"><a href="regularpolygons.html#cb133-74"></a>  glUniform1f(scaleLocation, scale);</span></code></pre></div>
<p>Na linha 66, <code>translation</code> contém coordenadas 2D aleatórias no intervalo <span class="math inline">\([-1,1]\)</span>. Na linha 72, <code>scale</code> é um fator de escala aleatório no intervalo <span class="math inline">\([0.01, 0.25]\)</span>.</p>
<p>Nas linhas 67 e 73, <code>translationLocation</code> e <code>scaleLocation</code> contêm os identificadores de localização das variáveis uniformes do shader. Esse valores são obtidos com <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformLocation.xhtml"><code>glGetUniformLocation</code></a> passando o identificador do programa de shader como primeiro argumento e o nome da variável uniforme como segundo argumento.</p>
<p>A atribuição dos valores das variáveis uniformes é feita nas linhas 68 e 74. As funções <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"><code>glUniform*</code></a> têm como primeiro parâmetro a localização da variável uniforme que será modificada, seguida de uma lista de parâmetros que depende do sufixo no fim de <code>glUniform</code>:</p>
<ul>
<li>Em <code>glUniform2fv</code>, <code>2fv</code> significa que a variável uniforme é um arranjo de tuplas de dois valores <code>float</code>, isto é, um arranjo de <code>vec2</code>. Nesse caso, o segundo argumento é a quantidade de <code>vec2</code> que serão copiados. O argumento é <code>1</code> porque <code>translation</code> não é um arranjo de <code>vec2</code>. O terceiro argumento é um ponteiro para o início dos dados que serão copiados.</li>
<li>Em <code>glUniform1f</code>, <code>1f</code> significa que a variável uniforme é apenas um valor <code>float</code>. Nesse caso, o segundo argumento é simplesmente o valor <code>float</code> que será copiado.</li>
</ul>
<div class="infobox">
<svg style="height:1.4em;fill:#555;" viewBox="0 0 512 512">
<path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/>
</svg>
<div class="infoboxtitle">
Observação
</div>
<p>O formato geral de <code>glUniform</code> é <code>glUniform{1|2|3|4}{f|i|ui}[v]</code>:</p>
<ul>
<li><code>{1|2|3|4}</code> define o número de componentes do tipo de dado:
<ul>
<li><code>1</code> para <code>float</code>, <code>int</code>, <code>unsigned int</code> e <code>bool</code>;</li>
<li><code>2</code> para <code>vec2</code>, <code>ivec2</code>, <code>uvec2</code>, <code>bvec2</code>;</li>
<li><code>3</code> para <code>vec3</code>, <code>ivec3</code>, <code>uvec3</code>, <code>bvec3</code>;</li>
<li><code>4</code> para <code>vec4</code>, <code>ivec4</code>, <code>uvec4</code>, <code>bvec4</code>.</li>
</ul></li>
<li><code>{f|i|ui}</code> define o tipo de dado de cada componente:
<ul>
<li><code>f</code> para <code>float</code>, <code>vec2</code>, <code>vec3</code>, <code>vec4</code>;</li>
<li><code>i</code> para <code>int</code>, <code>ivec2</code>, <code>ivec3</code>, <code>ivec4</code>;</li>
<li><code>ui</code> para <code>unsigned int</code>, <code>uvec2</code>, <code>uvec3</code>, <code>uvec4</code>.</li>
</ul></li>
</ul>
<p>Tanto <code>f</code>, <code>i</code> e <code>ui</code> podem ser usados para copiar dados para variáveis uniformes booleanas (<code>bool</code>, <code>bvec2</code>, <code>bvec3</code>, <code>bvec4</code>). Nesse caso, <code>true</code> é qualquer valor diferente de zero.</p>
<p>Se o <code>v</code> final não é especificado, então <code>{1|2|3|4}</code> é também o número de parâmetros após o identificador de localização. Por exemplo:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb134-1"><a href="regularpolygons.html#cb134-1"></a><span class="co">// Variável uniform é um float ou bool</span></span>
<span id="cb134-2"><a href="regularpolygons.html#cb134-2"></a>glUniform1f(loc, <span class="fl">3.14</span><span class="bu">f</span>);        </span>
<span id="cb134-3"><a href="regularpolygons.html#cb134-3"></a></span>
<span id="cb134-4"><a href="regularpolygons.html#cb134-4"></a><span class="co">// Variável uniform é um unsigned int ou bool</span></span>
<span id="cb134-5"><a href="regularpolygons.html#cb134-5"></a>glUniform1ui(loc, <span class="dv">42</span>);</span>
<span id="cb134-6"><a href="regularpolygons.html#cb134-6"></a></span>
<span id="cb134-7"><a href="regularpolygons.html#cb134-7"></a><span class="co">// Variável uniform é um vec2 ou bvec2</span></span>
<span id="cb134-8"><a href="regularpolygons.html#cb134-8"></a>glUniform2f(loc, <span class="fl">0.0</span><span class="bu">f</span>, <span class="fl">10.5</span><span class="bu">f</span>);</span>
<span id="cb134-9"><a href="regularpolygons.html#cb134-9"></a></span>
<span id="cb134-10"><a href="regularpolygons.html#cb134-10"></a><span class="co">// Variável uniform é um ivec4 ou bvec4</span></span>
<span id="cb134-11"><a href="regularpolygons.html#cb134-11"></a>glUniform4i(loc, -<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">10</span>, <span class="dv">3</span>); </span></code></pre></div>
<p>Se o <code>v</code> é especificado, o segundo parâmetro é o número de elementos do arranjo, e o terceiro parâmetro é o ponteiro para os dados. Por exemplo:</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb135-1"><a href="regularpolygons.html#cb135-1"></a><span class="co">// Variável uniform é um float ou bool</span></span>
<span id="cb135-2"><a href="regularpolygons.html#cb135-2"></a><span class="dt">float</span> pi{<span class="fl">3.14</span><span class="bu">f</span>};</span>
<span id="cb135-3"><a href="regularpolygons.html#cb135-3"></a>glUniform1fv(loc, <span class="dv">1</span>, &amp;pi);</span>
<span id="cb135-4"><a href="regularpolygons.html#cb135-4"></a></span>
<span id="cb135-5"><a href="regularpolygons.html#cb135-5"></a><span class="co">// Variável uniform é um unsigned int ou bool</span></span>
<span id="cb135-6"><a href="regularpolygons.html#cb135-6"></a><span class="dt">unsigned</span> <span class="dt">int</span> answer{<span class="dv">42</span>};</span>
<span id="cb135-7"><a href="regularpolygons.html#cb135-7"></a>glUniform1uiv(loc, <span class="dv">1</span>, &amp;answer);</span>
<span id="cb135-8"><a href="regularpolygons.html#cb135-8"></a></span>
<span id="cb135-9"><a href="regularpolygons.html#cb135-9"></a><span class="co">// Variável uniform é um vec2 ou bvec2</span></span>
<span id="cb135-10"><a href="regularpolygons.html#cb135-10"></a>glm::vec2 foo{<span class="fl">0.0</span><span class="bu">f</span>, <span class="fl">10.5</span><span class="bu">f</span>};</span>
<span id="cb135-11"><a href="regularpolygons.html#cb135-11"></a>glUniform2fv(loc, <span class="dv">1</span>, &amp;foo.x);</span>
<span id="cb135-12"><a href="regularpolygons.html#cb135-12"></a></span>
<span id="cb135-13"><a href="regularpolygons.html#cb135-13"></a><span class="co">// Variável uniform é um ivec4[2] ou bvec4[2]</span></span>
<span id="cb135-14"><a href="regularpolygons.html#cb135-14"></a><span class="bu">std::</span>array bar{glm::ivec4{-<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">10</span>, <span class="dv">3</span>},</span>
<span id="cb135-15"><a href="regularpolygons.html#cb135-15"></a>               glm::ivec4{<span class="dv">7</span>, -<span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">90</span>}};</span>
<span id="cb135-16"><a href="regularpolygons.html#cb135-16"></a>glUniform4iv(loc, <span class="dv">2</span>, &amp;bar.at(<span class="dv">0</span>).x); </span></code></pre></div>
</div>
<p>Nas linhas 76 a 79 temos a chamada à função de renderização:</p>
<div class="sourceCode" id="cb136" startFrom="76"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 75;"><span id="cb136-76"><a href="regularpolygons.html#cb136-76"></a>  <span class="co">// Render</span></span>
<span id="cb136-77"><a href="regularpolygons.html#cb136-77"></a>  glBindVertexArray(<span class="va">m_vao</span>);</span>
<span id="cb136-78"><a href="regularpolygons.html#cb136-78"></a>  glDrawArrays(GL_TRIANGLE_FAN, <span class="dv">0</span>, sides + <span class="dv">2</span>);</span>
<span id="cb136-79"><a href="regularpolygons.html#cb136-79"></a>  glBindVertexArray(<span class="dv">0</span>);</span></code></pre></div>
<p>O VAO é vinculado na linha 77 e automaticamente ativa e configura a ligação dos VBOs com o programa de shader. O comando de renderização é chamado na linha 78. Observe o uso de <code>GL_TRIANGLE_FAN</code>. O número de vértices é <code>sides + 2</code> porque vamos definir nossos polígonos de tal modo que o número de vértices será sempre o número de lados mais dois, como mostra a figura <a href="regularpolygons.html#fig:regularpolygons2">5.2</a> para a definição de um pentágono:</p>
<div class="figure" style="text-align: center"><span id="fig:regularpolygons2"></span>
<img src="images/05_regularpolygons2.svg" alt="Pentágono formado por um leque de sete vértices." width="40%" />
<p class="caption">
Figura 5.2: Pentágono formado por um leque de sete vértices.
</p>
</div>
<p>No pentágono, o vértice de índice 6 tem a mesma posição do vértice de índice 1 para “fechar” o leque de triângulos. Na verdade, o leque poderia definir um pentágono com apenas cinco vértices, como mostra a figura <a href="regularpolygons.html#fig:regularpolygons3">5.3</a>:</p>
<div class="figure" style="text-align: center"><span id="fig:regularpolygons3"></span>
<img src="images/05_regularpolygons3.svg" alt="Pentágono formado por um leque de cinco vértices." width="40%" />
<p class="caption">
Figura 5.3: Pentágono formado por um leque de cinco vértices.
</p>
</div>
<p>A escolha de manter o vértice de índice 0 no centro é proposital, pois permite simular um efeito de gradiente de cor parecido com um gradiente radial. Para isto, basta atribuir uma cor ao vértice 0, e outra cor aos demais vértices. Como os atributos dos vértices são interpolados linearmente pelo rasterizador para cada fragmento gerado, o resultado será um gradiente. A figura <a href="regularpolygons.html#fig:regularpolygons4">5.4</a> mostra um exemplo usando amarelo no vértice central e azul nos demais vértices:</p>
<div class="figure" style="text-align: center"><span id="fig:regularpolygons4"></span>
<img src="images/05_regularpolygons4.svg" alt="Pentágono com gradiente de cor formado através da interpolação do atributo de cor dos vértices." width="40%" />
<p class="caption">
Figura 5.4: Pentágono com gradiente de cor formado através da interpolação do atributo de cor dos vértices.
</p>
</div>
<p>Continuando com a definição dos métodos de <code>OpenGLWindow</code>, definiremos <code>OpenGLWindow::paintUI()</code> usando o código a seguir. Ele é bem parecido com o do projeto anterior. A diferença é que, no lugar de <code>ImGui::ColorEdit3</code>, criaremos um slider para controlar o valor de <code>m_delay</code> e criaremos um botão para limpar a janela:</p>
<div class="sourceCode" id="cb137" startFrom="84"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 83;"><span id="cb137-84"><a href="regularpolygons.html#cb137-84"></a><span class="dt">void</span> OpenGLWindow::paintUI() {</span>
<span id="cb137-85"><a href="regularpolygons.html#cb137-85"></a>  abcg::OpenGLWindow::paintUI();</span>
<span id="cb137-86"><a href="regularpolygons.html#cb137-86"></a></span>
<span id="cb137-87"><a href="regularpolygons.html#cb137-87"></a>  {</span>
<span id="cb137-88"><a href="regularpolygons.html#cb137-88"></a>    <span class="kw">auto</span> widgetSize{ImVec2(<span class="dv">200</span>, <span class="dv">72</span>)};</span>
<span id="cb137-89"><a href="regularpolygons.html#cb137-89"></a>    ImGui::SetNextWindowPos(ImVec2(<span class="va">m_viewportWidth</span> - widgetSize.x - <span class="dv">5</span>,</span>
<span id="cb137-90"><a href="regularpolygons.html#cb137-90"></a>                                   <span class="va">m_viewportHeight</span> - widgetSize.y - <span class="dv">5</span>));</span>
<span id="cb137-91"><a href="regularpolygons.html#cb137-91"></a>    ImGui::SetNextWindowSize(widgetSize);</span>
<span id="cb137-92"><a href="regularpolygons.html#cb137-92"></a>    <span class="kw">auto</span> windowFlags{ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse |</span>
<span id="cb137-93"><a href="regularpolygons.html#cb137-93"></a>                     ImGuiWindowFlags_NoTitleBar};</span>
<span id="cb137-94"><a href="regularpolygons.html#cb137-94"></a>    ImGui::Begin(<span class="st">&quot; &quot;</span>, <span class="kw">nullptr</span>, windowFlags);</span>
<span id="cb137-95"><a href="regularpolygons.html#cb137-95"></a></span>
<span id="cb137-96"><a href="regularpolygons.html#cb137-96"></a>    ImGui::PushItemWidth(<span class="dv">140</span>);</span>
<span id="cb137-97"><a href="regularpolygons.html#cb137-97"></a>    ImGui::SliderInt(<span class="st">&quot;Delay&quot;</span>, &amp;<span class="va">m_delay</span>, <span class="dv">0</span>, <span class="dv">200</span>, <span class="st">&quot;</span><span class="sc">%d</span><span class="st"> ms&quot;</span>);</span>
<span id="cb137-98"><a href="regularpolygons.html#cb137-98"></a>    ImGui::PopItemWidth();</span>
<span id="cb137-99"><a href="regularpolygons.html#cb137-99"></a></span>
<span id="cb137-100"><a href="regularpolygons.html#cb137-100"></a>    <span class="cf">if</span> (ImGui::Button(<span class="st">&quot;Clear window&quot;</span>, ImVec2(-<span class="dv">1</span>, <span class="dv">30</span>))) {</span>
<span id="cb137-101"><a href="regularpolygons.html#cb137-101"></a>      glClear(GL_COLOR_BUFFER_BIT);</span>
<span id="cb137-102"><a href="regularpolygons.html#cb137-102"></a>    }</span>
<span id="cb137-103"><a href="regularpolygons.html#cb137-103"></a></span>
<span id="cb137-104"><a href="regularpolygons.html#cb137-104"></a>    ImGui::End();</span>
<span id="cb137-105"><a href="regularpolygons.html#cb137-105"></a>  }</span>
<span id="cb137-106"><a href="regularpolygons.html#cb137-106"></a>}</span></code></pre></div>
<p>A definição de <code>OpenGLWindow::resizeGL</code> e <code>OpenGLWindow::terminateGL</code> é idêntica à do projeto <code>coloredtriangles</code>.</p>
<p>Vamos agora à definição do método <code>OpenGLWindow::setupModel</code>. O código completo é mostrado abaixo, mas analisaremos cada trecho em seguida:</p>
<div class="sourceCode" id="cb138" startFrom="122"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 121;"><span id="cb138-122"><a href="regularpolygons.html#cb138-122"></a><span class="dt">void</span> OpenGLWindow::setupModel(<span class="dt">int</span> sides) {</span>
<span id="cb138-123"><a href="regularpolygons.html#cb138-123"></a>  <span class="co">// Release previous resources, if any</span></span>
<span id="cb138-124"><a href="regularpolygons.html#cb138-124"></a>  glDeleteBuffers(<span class="dv">1</span>, &amp;<span class="va">m_vboPositions</span>);</span>
<span id="cb138-125"><a href="regularpolygons.html#cb138-125"></a>  glDeleteBuffers(<span class="dv">1</span>, &amp;<span class="va">m_vboColors</span>);</span>
<span id="cb138-126"><a href="regularpolygons.html#cb138-126"></a>  glDeleteVertexArrays(<span class="dv">1</span>, &amp;<span class="va">m_vao</span>);</span>
<span id="cb138-127"><a href="regularpolygons.html#cb138-127"></a></span>
<span id="cb138-128"><a href="regularpolygons.html#cb138-128"></a>  <span class="co">// Select random colors for the radial gradient</span></span>
<span id="cb138-129"><a href="regularpolygons.html#cb138-129"></a>  <span class="bu">std::</span>uniform_real_distribution&lt;<span class="dt">float</span>&gt; rd(<span class="fl">0.0</span><span class="bu">f</span>, <span class="fl">1.0</span><span class="bu">f</span>);</span>
<span id="cb138-130"><a href="regularpolygons.html#cb138-130"></a>  glm::vec3 color1{rd(<span class="va">m_randomEngine</span>), rd(<span class="va">m_randomEngine</span>), rd(<span class="va">m_randomEngine</span>)};</span>
<span id="cb138-131"><a href="regularpolygons.html#cb138-131"></a>  glm::vec3 color2{rd(<span class="va">m_randomEngine</span>), rd(<span class="va">m_randomEngine</span>), rd(<span class="va">m_randomEngine</span>)};</span>
<span id="cb138-132"><a href="regularpolygons.html#cb138-132"></a></span>
<span id="cb138-133"><a href="regularpolygons.html#cb138-133"></a>  <span class="co">// Minimum number of sides is 3</span></span>
<span id="cb138-134"><a href="regularpolygons.html#cb138-134"></a>  sides = <span class="bu">std::</span>max(<span class="dv">3</span>, sides);</span>
<span id="cb138-135"><a href="regularpolygons.html#cb138-135"></a></span>
<span id="cb138-136"><a href="regularpolygons.html#cb138-136"></a>  <span class="bu">std::</span>vector&lt;glm::vec2&gt; positions(<span class="dv">0</span>);</span>
<span id="cb138-137"><a href="regularpolygons.html#cb138-137"></a>  <span class="bu">std::</span>vector&lt;glm::vec3&gt; colors(<span class="dv">0</span>);</span>
<span id="cb138-138"><a href="regularpolygons.html#cb138-138"></a></span>
<span id="cb138-139"><a href="regularpolygons.html#cb138-139"></a>  <span class="co">// Polygon center</span></span>
<span id="cb138-140"><a href="regularpolygons.html#cb138-140"></a>  positions.emplace_back(<span class="dv">0</span>, <span class="dv">0</span>);</span>
<span id="cb138-141"><a href="regularpolygons.html#cb138-141"></a>  colors.push_back(color1);</span>
<span id="cb138-142"><a href="regularpolygons.html#cb138-142"></a></span>
<span id="cb138-143"><a href="regularpolygons.html#cb138-143"></a>  <span class="co">// Border vertices</span></span>
<span id="cb138-144"><a href="regularpolygons.html#cb138-144"></a>  <span class="kw">auto</span> step{M_PI * <span class="dv">2</span> / sides};</span>
<span id="cb138-145"><a href="regularpolygons.html#cb138-145"></a>  <span class="cf">for</span> (<span class="kw">auto</span> angle : iter::range(<span class="fl">0.0</span>, M_PI * <span class="dv">2</span>, step)) {</span>
<span id="cb138-146"><a href="regularpolygons.html#cb138-146"></a>    positions.emplace_back(<span class="bu">std::</span>cos(angle), <span class="bu">std::</span>sin(angle));</span>
<span id="cb138-147"><a href="regularpolygons.html#cb138-147"></a>    colors.push_back(color2);</span>
<span id="cb138-148"><a href="regularpolygons.html#cb138-148"></a>  }</span>
<span id="cb138-149"><a href="regularpolygons.html#cb138-149"></a></span>
<span id="cb138-150"><a href="regularpolygons.html#cb138-150"></a>  <span class="co">// Duplicate second vertex</span></span>
<span id="cb138-151"><a href="regularpolygons.html#cb138-151"></a>  positions.push_back(positions.at(<span class="dv">1</span>));</span>
<span id="cb138-152"><a href="regularpolygons.html#cb138-152"></a>  colors.push_back(color2);</span>
<span id="cb138-153"><a href="regularpolygons.html#cb138-153"></a></span>
<span id="cb138-154"><a href="regularpolygons.html#cb138-154"></a>  <span class="co">// Generate VBO of positions</span></span>
<span id="cb138-155"><a href="regularpolygons.html#cb138-155"></a>  glGenBuffers(<span class="dv">1</span>, &amp;<span class="va">m_vboPositions</span>);</span>
<span id="cb138-156"><a href="regularpolygons.html#cb138-156"></a>  glBindBuffer(GL_ARRAY_BUFFER, <span class="va">m_vboPositions</span>);</span>
<span id="cb138-157"><a href="regularpolygons.html#cb138-157"></a>  glBufferData(GL_ARRAY_BUFFER, positions.size() * <span class="kw">sizeof</span>(glm::vec2),</span>
<span id="cb138-158"><a href="regularpolygons.html#cb138-158"></a>               positions.data(), GL_STATIC_DRAW);</span>
<span id="cb138-159"><a href="regularpolygons.html#cb138-159"></a>  glBindBuffer(GL_ARRAY_BUFFER, <span class="dv">0</span>);</span>
<span id="cb138-160"><a href="regularpolygons.html#cb138-160"></a></span>
<span id="cb138-161"><a href="regularpolygons.html#cb138-161"></a>  <span class="co">// Generate VBO of colors</span></span>
<span id="cb138-162"><a href="regularpolygons.html#cb138-162"></a>  glGenBuffers(<span class="dv">1</span>, &amp;<span class="va">m_vboColors</span>);</span>
<span id="cb138-163"><a href="regularpolygons.html#cb138-163"></a>  glBindBuffer(GL_ARRAY_BUFFER, <span class="va">m_vboColors</span>);</span>
<span id="cb138-164"><a href="regularpolygons.html#cb138-164"></a>  glBufferData(GL_ARRAY_BUFFER, colors.size() * <span class="kw">sizeof</span>(glm::vec3),</span>
<span id="cb138-165"><a href="regularpolygons.html#cb138-165"></a>               colors.data(), GL_STATIC_DRAW);</span>
<span id="cb138-166"><a href="regularpolygons.html#cb138-166"></a>  glBindBuffer(GL_ARRAY_BUFFER, <span class="dv">0</span>);</span>
<span id="cb138-167"><a href="regularpolygons.html#cb138-167"></a></span>
<span id="cb138-168"><a href="regularpolygons.html#cb138-168"></a>  <span class="co">// Get location of attributes in the program</span></span>
<span id="cb138-169"><a href="regularpolygons.html#cb138-169"></a>  GLint positionAttribute{glGetAttribLocation(<span class="va">m_program</span>, <span class="st">&quot;inPosition&quot;</span>)};</span>
<span id="cb138-170"><a href="regularpolygons.html#cb138-170"></a>  GLint colorAttribute{glGetAttribLocation(<span class="va">m_program</span>, <span class="st">&quot;inColor&quot;</span>)};</span>
<span id="cb138-171"><a href="regularpolygons.html#cb138-171"></a></span>
<span id="cb138-172"><a href="regularpolygons.html#cb138-172"></a>  <span class="co">// Create VAO</span></span>
<span id="cb138-173"><a href="regularpolygons.html#cb138-173"></a>  glGenVertexArrays(<span class="dv">1</span>, &amp;<span class="va">m_vao</span>);</span>
<span id="cb138-174"><a href="regularpolygons.html#cb138-174"></a></span>
<span id="cb138-175"><a href="regularpolygons.html#cb138-175"></a>  <span class="co">// Bind vertex attributes to current VAO</span></span>
<span id="cb138-176"><a href="regularpolygons.html#cb138-176"></a>  glBindVertexArray(<span class="va">m_vao</span>);</span>
<span id="cb138-177"><a href="regularpolygons.html#cb138-177"></a></span>
<span id="cb138-178"><a href="regularpolygons.html#cb138-178"></a>  glEnableVertexAttribArray(positionAttribute);</span>
<span id="cb138-179"><a href="regularpolygons.html#cb138-179"></a>  glBindBuffer(GL_ARRAY_BUFFER, <span class="va">m_vboPositions</span>);</span>
<span id="cb138-180"><a href="regularpolygons.html#cb138-180"></a>  glVertexAttribPointer(positionAttribute, <span class="dv">2</span>, GL_FLOAT, GL_FALSE, <span class="dv">0</span>, <span class="kw">nullptr</span>);</span>
<span id="cb138-181"><a href="regularpolygons.html#cb138-181"></a>  glBindBuffer(GL_ARRAY_BUFFER, <span class="dv">0</span>);</span>
<span id="cb138-182"><a href="regularpolygons.html#cb138-182"></a></span>
<span id="cb138-183"><a href="regularpolygons.html#cb138-183"></a>  glEnableVertexAttribArray(colorAttribute);</span>
<span id="cb138-184"><a href="regularpolygons.html#cb138-184"></a>  glBindBuffer(GL_ARRAY_BUFFER, <span class="va">m_vboColors</span>);</span>
<span id="cb138-185"><a href="regularpolygons.html#cb138-185"></a>  glVertexAttribPointer(colorAttribute, <span class="dv">3</span>, GL_FLOAT, GL_FALSE, <span class="dv">0</span>, <span class="kw">nullptr</span>);</span>
<span id="cb138-186"><a href="regularpolygons.html#cb138-186"></a>  glBindBuffer(GL_ARRAY_BUFFER, <span class="dv">0</span>);</span>
<span id="cb138-187"><a href="regularpolygons.html#cb138-187"></a></span>
<span id="cb138-188"><a href="regularpolygons.html#cb138-188"></a>  <span class="co">// End of binding to current VAO</span></span>
<span id="cb138-189"><a href="regularpolygons.html#cb138-189"></a>  glBindVertexArray(<span class="dv">0</span>);</span>
<span id="cb138-190"><a href="regularpolygons.html#cb138-190"></a>}</span></code></pre></div>
<p>No início do método, os VBOs e o VAO são liberados caso tenham sido criados anteriormente:</p>
<div class="sourceCode" id="cb139" startFrom="123"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 122;"><span id="cb139-123"><a href="regularpolygons.html#cb139-123"></a>  <span class="co">// Release previous resources, if any</span></span>
<span id="cb139-124"><a href="regularpolygons.html#cb139-124"></a>  glDeleteBuffers(<span class="dv">1</span>, &amp;<span class="va">m_vboPositions</span>);</span>
<span id="cb139-125"><a href="regularpolygons.html#cb139-125"></a>  glDeleteBuffers(<span class="dv">1</span>, &amp;<span class="va">m_vboColors</span>);</span>
<span id="cb139-126"><a href="regularpolygons.html#cb139-126"></a>  glDeleteVertexArrays(<span class="dv">1</span>, &amp;<span class="va">m_vao</span>);</span></code></pre></div>
<p>Em seguida temos o código que cria os vértices do polígono regular (arranjos <code>positions</code> e <code>colors</code>):</p>
<div class="sourceCode" id="cb140" startFrom="128"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 127;"><span id="cb140-128"><a href="regularpolygons.html#cb140-128"></a>  <span class="co">// Select random colors for the radial gradient</span></span>
<span id="cb140-129"><a href="regularpolygons.html#cb140-129"></a>  <span class="bu">std::</span>uniform_real_distribution&lt;<span class="dt">float</span>&gt; rd(<span class="fl">0.0</span><span class="bu">f</span>, <span class="fl">1.0</span><span class="bu">f</span>);</span>
<span id="cb140-130"><a href="regularpolygons.html#cb140-130"></a>  glm::vec3 color1{rd(<span class="va">m_randomEngine</span>), rd(<span class="va">m_randomEngine</span>), rd(<span class="va">m_randomEngine</span>)};</span>
<span id="cb140-131"><a href="regularpolygons.html#cb140-131"></a>  glm::vec3 color2{rd(<span class="va">m_randomEngine</span>), rd(<span class="va">m_randomEngine</span>), rd(<span class="va">m_randomEngine</span>)};</span>
<span id="cb140-132"><a href="regularpolygons.html#cb140-132"></a></span>
<span id="cb140-133"><a href="regularpolygons.html#cb140-133"></a>  <span class="co">// Minimum number of sides is 3</span></span>
<span id="cb140-134"><a href="regularpolygons.html#cb140-134"></a>  sides = <span class="bu">std::</span>max(<span class="dv">3</span>, sides);</span>
<span id="cb140-135"><a href="regularpolygons.html#cb140-135"></a></span>
<span id="cb140-136"><a href="regularpolygons.html#cb140-136"></a>  <span class="bu">std::</span>vector&lt;glm::vec2&gt; positions(<span class="dv">0</span>);</span>
<span id="cb140-137"><a href="regularpolygons.html#cb140-137"></a>  <span class="bu">std::</span>vector&lt;glm::vec3&gt; colors(<span class="dv">0</span>);</span>
<span id="cb140-138"><a href="regularpolygons.html#cb140-138"></a></span>
<span id="cb140-139"><a href="regularpolygons.html#cb140-139"></a>  <span class="co">// Polygon center</span></span>
<span id="cb140-140"><a href="regularpolygons.html#cb140-140"></a>  positions.emplace_back(<span class="dv">0</span>, <span class="dv">0</span>);</span>
<span id="cb140-141"><a href="regularpolygons.html#cb140-141"></a>  colors.push_back(color1);</span>
<span id="cb140-142"><a href="regularpolygons.html#cb140-142"></a></span>
<span id="cb140-143"><a href="regularpolygons.html#cb140-143"></a>  <span class="co">// Border vertices</span></span>
<span id="cb140-144"><a href="regularpolygons.html#cb140-144"></a>  <span class="kw">auto</span> step{M_PI * <span class="dv">2</span> / sides};</span>
<span id="cb140-145"><a href="regularpolygons.html#cb140-145"></a>  <span class="cf">for</span> (<span class="kw">auto</span> angle : iter::range(<span class="fl">0.0</span>, M_PI * <span class="dv">2</span>, step)) {</span>
<span id="cb140-146"><a href="regularpolygons.html#cb140-146"></a>    positions.emplace_back(<span class="bu">std::</span>cos(angle), <span class="bu">std::</span>sin(angle));</span>
<span id="cb140-147"><a href="regularpolygons.html#cb140-147"></a>    colors.push_back(color2);</span>
<span id="cb140-148"><a href="regularpolygons.html#cb140-148"></a>  }</span>
<span id="cb140-149"><a href="regularpolygons.html#cb140-149"></a></span>
<span id="cb140-150"><a href="regularpolygons.html#cb140-150"></a>  <span class="co">// Duplicate second vertex</span></span>
<span id="cb140-151"><a href="regularpolygons.html#cb140-151"></a>  positions.push_back(positions.at(<span class="dv">1</span>));</span>
<span id="cb140-152"><a href="regularpolygons.html#cb140-152"></a>  colors.push_back(color2);</span></code></pre></div>
<p>Duas cores RGB são sorteadas nas linhas 130 e 131. <code>color1</code> é utilizada na definição do vértice do centro (linhas 140 e 141), e <code>color2</code> é utilizada para os demais vértices.</p>
<p>Nas linhas 144 a 148, a posição dos vértices é calculada com a equação paramétrica de um círculo unitário:</p>
<p><span class="math display">\[
\begin{eqnarray}
x&amp;=&amp;cos(t),\\
y&amp;=&amp;sin(t),
\end{eqnarray}
\]</span></p>
<p>onde <span class="math inline">\(t\)</span> é o ângulo (<code>angle</code>) que varia de <span class="math inline">\(0\)</span> a <span class="math inline">\(2\pi\)</span> usando um tamanho do passo (<code>step</code>) igual à divisão de <span class="math inline">\(2\pi\)</span> pelo número de lados do polígono.</p>
<p>A definição dos VBOs é semelhante à forma utilizada no projeto anterior. Nas linhas 178 a 186 é definido como os dados dos VBOs serão mapeados para a entrada do vertex shader. Vamos nos concentrar na definição do mapeamento de <code>m_vboPositions</code> (o mapeamento de <code>m_vboColors</code> é similar):</p>
<div class="sourceCode" id="cb141" startFrom="178"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 177;"><span id="cb141-178"><a href="regularpolygons.html#cb141-178"></a>  glEnableVertexAttribArray(positionAttribute);</span>
<span id="cb141-179"><a href="regularpolygons.html#cb141-179"></a>  glBindBuffer(GL_ARRAY_BUFFER, <span class="va">m_vboPositions</span>);</span>
<span id="cb141-180"><a href="regularpolygons.html#cb141-180"></a>  glVertexAttribPointer(positionAttribute, <span class="dv">2</span>, GL_FLOAT, GL_FALSE, <span class="dv">0</span>, <span class="kw">nullptr</span>);</span>
<span id="cb141-181"><a href="regularpolygons.html#cb141-181"></a>  glBindBuffer(GL_ARRAY_BUFFER, <span class="dv">0</span>);</span></code></pre></div>
<p>Na linha 178, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml"><code>glEnableVertexAttribArray</code></a> habilita o atributo de posição do vértice (<code>inPosition</code>) para ser utilizado durante a renderização.</p>
<p>Em seguida, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml"><code>glBindBuffer</code></a> vincula o VBO <code>m_vboPositions</code>, que contém os dados das posições dos vértices.</p>
<p>Na linha 180, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml"><code>glVertexAttribPointer</code></a> define como os dados do VBO serão mapeados para o atributo. Lembre-se que o VBO é apenas um arranjo linear de bytes copiados pela função <code>glBufferData</code>. Com <code>glVertexAttribPointer</code>, informamos ao OpenGL como esses bytes devem ser mapeados para uma variável de atributo de entrada do vertex shader. A assinatura de <code>glVertexAttribPointer</code> é a seguinte:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb142-1"><a href="regularpolygons.html#cb142-1"></a><span class="dt">void</span> glVertexAttribPointer(GLuint index, </span>
<span id="cb142-2"><a href="regularpolygons.html#cb142-2"></a>                           GLint size,</span>
<span id="cb142-3"><a href="regularpolygons.html#cb142-3"></a>                           GLenum type,</span>
<span id="cb142-4"><a href="regularpolygons.html#cb142-4"></a>                           GLboolean normalized,</span>
<span id="cb142-5"><a href="regularpolygons.html#cb142-5"></a>                           GLsizei stride,</span>
<span id="cb142-6"><a href="regularpolygons.html#cb142-6"></a>                           <span class="at">const</span> <span class="dt">void</span> * pointer);</span></code></pre></div>
<p>Os parâmetros são descritos a seguir:</p>
<ol style="list-style-type: decimal">
<li><code>index</code>: índice do atributo que será modificado. No nosso caso (linha 180) é <code>positionAttribute</code>.</li>
<li><code>size</code>: número de componentes do atributo. No nosso caso é <code>2</code> pois <code>inPosition</code> é um <code>vec2</code>, isto é, um atributo de dois componentes.</li>
<li><code>type</code>: tipo de dado de cada valor do VBO. Usamos <code>GL_FLOAT</code> pois cada coordenada <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span> do VBO de posições é um <code>float</code>.</li>
<li><code>normalized</code>: flag que indica se valores inteiros devem ser normalizados para <span class="math inline">\([-1,1]\)</span> (para valores com sinal) ou <span class="math inline">\([0,1]\)</span> (para valores sem sinal) quando forem enviados ao atributo. Usamos <code>GL_FALSE</code> porque nossas coordenadas são valores do tipo <code>float</code>;</li>
<li><code>stride</code>: é o número de bytes entre o início do atributo de um vértice e o início do atributo do próximo vértice. O argumento <code>0</code> indica que não há bytes extras entre uma posição <span class="math inline">\((x,y)\)</span> e a posição <span class="math inline">\((x,y)\)</span> do vértice seguinte.</li>
<li><code>pointer</code>: apesar do nome, não é um ponteiro, mas um deslocamento em bytes que informa qual é a posição do primeiro componente do atributo. Usamos <code>nullptr</code>, que corresponde a zero, pois não há bytes extras no início do VBO antes da primeira posição <span class="math inline">\((x,y)\)</span>.</li>
</ol>
<div class="infobox">
<svg style="height:1.4em;fill:#555;" viewBox="0 0 512 512">
<path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/>
</svg>
<div class="infoboxtitle">
Observação
</div>
<p>Os parâmetros <code>stride</code> e <code>pointer</code> de <code>glVertexAttribPointer</code> podem ser utilizados para especificar o mapeamento de VBOs que contém <em>dados intercalados</em> (<em>interleaved data</em>).</p>
<p>Nosso <code>m_vboPositions</code> não usa dados intercalados. O arranjo contém apenas posições <span class="math inline">\((x,y)\)</span> em sequência. Assim, para um triângulo (três vértices), o VBO é um arranjo no formato:</p>
<p><span class="math display">\[[x\; y\; x\; y\; x\; y],\]</span></p>
<p>onde cada grupo de <span class="math inline">\((x, y)\)</span> é a posição de um vértice, e tanto <span class="math inline">\(x\)</span> quanto <span class="math inline">\(y\)</span> são do tipo <code>float</code>.</p>
<p>Da mesma forma, <code>m_vboColors</code> não usa dados intercalados. Para a definição das cores dos vértices de um triângulo, o arranjo tem o formato:</p>
<p><span class="math display">\[[r\; g\; b\; r\; g\; b\; r\; g\; b],\]</span></p>
<p>onde cada grupo de <span class="math inline">\((r,g,b)\)</span> define a cor de um vértice, e <span class="math inline">\(r\)</span>, <span class="math inline">\(g\)</span> e <span class="math inline">\(b\)</span> também são do tipo <code>float</code>.</p>
<p>Quando os dados não são intercalados, podemos especificar <code>0</code> como argumento de <code>stride</code>, que é o que fizemos. Além disso, <code>pointer</code> também é <code>0</code>.</p>
<p>Suponha agora que os dados tenham sido intercalados em um único VBO no seguinte formato:</p>
<p><span class="math display">\[[x\; y\; r\; g\; b\; x\; y\; r\; g\; b\; x\; y\; r\; g\; b].\]</span></p>
<p>Agora, o atributo de posição <span class="math inline">\((x,y)\)</span> tem um stride que corresponde à quantidade de bytes contida em <span class="math inline">\((x,y,r,g,b)\)</span>. Esse valor é 20 se cada <code>float</code> tiver 4 bytes. <code>pointer</code> continua sendo <code>0</code>, pois não há deslocamento no início do arranjo.</p>
<p>O atributo de cor <span class="math inline">\((r,g,b)\)</span> também tem um stride de 20 bytes. Entretanto, <code>pointer</code> precisa ser <code>8</code>, pois <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span> formam 8 bytes antes do início do primeiro grupo de <span class="math inline">\((r,g,b)\)</span>.</p>
<p>Suponha agora um único VBO no formato a seguir:</p>
<p><span class="math display">\[[x\; y\; x\; y\; x\; y\; r\; g\; b\; r\; g\; b\; r\; g\; b].\]</span></p>
<p>O stride da posição pode ser <code>0</code>, pois após um grupo de <span class="math inline">\((x,y)\)</span> há imediatamente outro <span class="math inline">\((x,y)\)</span><a href="#fn23" class="footnote-ref" id="fnref23"><sup>23</sup></a>. O stride da cor também pode ser <code>0</code> pelo mesmo motivo. Entretanto, o <code>pointer</code> para o atributo de cor precisa ser 24 (8*3=24 bytes), pois o primeiro grupo de <span class="math inline">\((r,g,b)\)</span> ocorre apenas depois de três grupos de <span class="math inline">\((x,y)\)</span>.</p>
<p>Com todas essas opções de formatação de VBOs, não há uma forma mais certa ou mais recomendada de organizar os dados. É possível que algum driver use algum formato de forma mais eficiente, mas isso só pode ser determinado através de medição de tempo. Na prática, use o formato que melhor fizer sentido para o caso de uso.</p>
<p>Para simplificar, fizemos as contas supondo 4 bytes por <code>float</code>, mas lembre-se sempre de usar <code>sizeof(float)</code> pois o tamanho de um <code>float</code> pode variar dependendo da arquitetura.</p>
</div>
<p>O código completo de <code>openglwindow.cpp</code> é mostrado a seguir:</p>
<div class="sourceCode" id="cb143" startFrom="1"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb143-1"><a href="regularpolygons.html#cb143-1"></a><span class="pp">#include </span><span class="im">&quot;openglwindow.hpp&quot;</span></span>
<span id="cb143-2"><a href="regularpolygons.html#cb143-2"></a></span>
<span id="cb143-3"><a href="regularpolygons.html#cb143-3"></a><span class="pp">#include </span><span class="im">&lt;imgui.h&gt;</span></span>
<span id="cb143-4"><a href="regularpolygons.html#cb143-4"></a></span>
<span id="cb143-5"><a href="regularpolygons.html#cb143-5"></a><span class="pp">#include </span><span class="im">&lt;cppitertools/itertools.hpp&gt;</span></span>
<span id="cb143-6"><a href="regularpolygons.html#cb143-6"></a></span>
<span id="cb143-7"><a href="regularpolygons.html#cb143-7"></a><span class="pp">#include </span><span class="im">&quot;abcg.hpp&quot;</span></span>
<span id="cb143-8"><a href="regularpolygons.html#cb143-8"></a></span>
<span id="cb143-9"><a href="regularpolygons.html#cb143-9"></a><span class="dt">void</span> OpenGLWindow::initializeGL() {</span>
<span id="cb143-10"><a href="regularpolygons.html#cb143-10"></a>  <span class="at">const</span> <span class="kw">auto</span> *vertexShader{<span class="st">R&quot;gl(</span></span>
<span id="cb143-11"><a href="regularpolygons.html#cb143-11"></a><span class="st">    #version 410</span></span>
<span id="cb143-12"><a href="regularpolygons.html#cb143-12"></a></span>
<span id="cb143-13"><a href="regularpolygons.html#cb143-13"></a><span class="st">    layout(location = 0) in vec2 inPosition;</span></span>
<span id="cb143-14"><a href="regularpolygons.html#cb143-14"></a><span class="st">    layout(location = 1) in vec4 inColor;</span></span>
<span id="cb143-15"><a href="regularpolygons.html#cb143-15"></a></span>
<span id="cb143-16"><a href="regularpolygons.html#cb143-16"></a><span class="st">    uniform vec2 translation;</span></span>
<span id="cb143-17"><a href="regularpolygons.html#cb143-17"></a><span class="st">    uniform float scale;</span></span>
<span id="cb143-18"><a href="regularpolygons.html#cb143-18"></a></span>
<span id="cb143-19"><a href="regularpolygons.html#cb143-19"></a><span class="st">    out vec4 fragColor;</span></span>
<span id="cb143-20"><a href="regularpolygons.html#cb143-20"></a></span>
<span id="cb143-21"><a href="regularpolygons.html#cb143-21"></a><span class="st">    void main() {</span></span>
<span id="cb143-22"><a href="regularpolygons.html#cb143-22"></a><span class="st">      vec2 newPosition = inPosition * scale + translation;</span></span>
<span id="cb143-23"><a href="regularpolygons.html#cb143-23"></a><span class="st">      gl_Position = vec4(newPosition, 0, 1);</span></span>
<span id="cb143-24"><a href="regularpolygons.html#cb143-24"></a><span class="st">      fragColor = inColor;</span></span>
<span id="cb143-25"><a href="regularpolygons.html#cb143-25"></a><span class="st">    }</span></span>
<span id="cb143-26"><a href="regularpolygons.html#cb143-26"></a><span class="st">  )gl&quot;};</span></span>
<span id="cb143-27"><a href="regularpolygons.html#cb143-27"></a></span>
<span id="cb143-28"><a href="regularpolygons.html#cb143-28"></a><span class="st">  const auto *fragmentShader{R&quot;gl(</span></span>
<span id="cb143-29"><a href="regularpolygons.html#cb143-29"></a><span class="st">    #version 410</span></span>
<span id="cb143-30"><a href="regularpolygons.html#cb143-30"></a></span>
<span id="cb143-31"><a href="regularpolygons.html#cb143-31"></a><span class="st">    in vec4 fragColor;</span></span>
<span id="cb143-32"><a href="regularpolygons.html#cb143-32"></a></span>
<span id="cb143-33"><a href="regularpolygons.html#cb143-33"></a><span class="st">    out vec4 outColor;</span></span>
<span id="cb143-34"><a href="regularpolygons.html#cb143-34"></a></span>
<span id="cb143-35"><a href="regularpolygons.html#cb143-35"></a><span class="st">    void main() { outColor = fragColor; }</span></span>
<span id="cb143-36"><a href="regularpolygons.html#cb143-36"></a><span class="st">  )gl&quot;};</span></span>
<span id="cb143-37"><a href="regularpolygons.html#cb143-37"></a></span>
<span id="cb143-38"><a href="regularpolygons.html#cb143-38"></a><span class="st">  // Create shader program</span></span>
<span id="cb143-39"><a href="regularpolygons.html#cb143-39"></a><span class="st">  m_program = createProgramFromString(vertexShader, fragmentShader);</span></span>
<span id="cb143-40"><a href="regularpolygons.html#cb143-40"></a></span>
<span id="cb143-41"><a href="regularpolygons.html#cb143-41"></a><span class="st">  // Clear window</span></span>
<span id="cb143-42"><a href="regularpolygons.html#cb143-42"></a><span class="st">  glClearColor(0, 0, 0, 1);</span></span>
<span id="cb143-43"><a href="regularpolygons.html#cb143-43"></a><span class="st">  glClear(GL_COLOR_BUFFER_BIT);</span></span>
<span id="cb143-44"><a href="regularpolygons.html#cb143-44"></a></span>
<span id="cb143-45"><a href="regularpolygons.html#cb143-45"></a><span class="st">  // Start pseudo-random number generator</span></span>
<span id="cb143-46"><a href="regularpolygons.html#cb143-46"></a><span class="st">  auto seed{std::chrono::steady_clock::now().time_since_epoch().count()};</span></span>
<span id="cb143-47"><a href="regularpolygons.html#cb143-47"></a><span class="st">  m_randomEngine.seed(seed);</span></span>
<span id="cb143-48"><a href="regularpolygons.html#cb143-48"></a><span class="st">}</span></span>
<span id="cb143-49"><a href="regularpolygons.html#cb143-49"></a></span>
<span id="cb143-50"><a href="regularpolygons.html#cb143-50"></a><span class="st">void OpenGLWindow::paintGL() {</span></span>
<span id="cb143-51"><a href="regularpolygons.html#cb143-51"></a><span class="st">  // Check whether to render the next polygon</span></span>
<span id="cb143-52"><a href="regularpolygons.html#cb143-52"></a><span class="st">  if (m_elapsedTimer.elapsed() &lt; m_delay / 1000.0) return;</span></span>
<span id="cb143-53"><a href="regularpolygons.html#cb143-53"></a><span class="st">  m_elapsedTimer.restart();</span></span>
<span id="cb143-54"><a href="regularpolygons.html#cb143-54"></a></span>
<span id="cb143-55"><a href="regularpolygons.html#cb143-55"></a><span class="st">  // Create a regular polygon with a number of sides in the range [3;20]</span></span>
<span id="cb143-56"><a href="regularpolygons.html#cb143-56"></a><span class="st">  std::uniform_int_distribution&lt;int&gt; intDist(3, 20);</span></span>
<span id="cb143-57"><a href="regularpolygons.html#cb143-57"></a><span class="st">  auto sides{intDist(m_randomEngine)};</span></span>
<span id="cb143-58"><a href="regularpolygons.html#cb143-58"></a><span class="st">  setupModel(sides);</span></span>
<span id="cb143-59"><a href="regularpolygons.html#cb143-59"></a></span>
<span id="cb143-60"><a href="regularpolygons.html#cb143-60"></a><span class="st">  glViewport(0, 0, m_viewportWidth, m_viewportHeight);</span></span>
<span id="cb143-61"><a href="regularpolygons.html#cb143-61"></a></span>
<span id="cb143-62"><a href="regularpolygons.html#cb143-62"></a><span class="st">  glUseProgram(m_program);</span></span>
<span id="cb143-63"><a href="regularpolygons.html#cb143-63"></a></span>
<span id="cb143-64"><a href="regularpolygons.html#cb143-64"></a><span class="st">  // Choose a random xy position from (-1, -1) to (1, 1)</span></span>
<span id="cb143-65"><a href="regularpolygons.html#cb143-65"></a><span class="st">  std::uniform_real_distribution&lt;float&gt; rd1(-1.0f, 1.0f);</span></span>
<span id="cb143-66"><a href="regularpolygons.html#cb143-66"></a><span class="st">  glm::vec2 translation{rd1(m_randomEngine), rd1(m_randomEngine)};</span></span>
<span id="cb143-67"><a href="regularpolygons.html#cb143-67"></a><span class="st">  GLint translationLocation{glGetUniformLocation(m_program, &quot;translation&quot;)};</span></span>
<span id="cb143-68"><a href="regularpolygons.html#cb143-68"></a><span class="st">  glUniform2fv(translationLocation, 1, &amp;translation.x);</span></span>
<span id="cb143-69"><a href="regularpolygons.html#cb143-69"></a></span>
<span id="cb143-70"><a href="regularpolygons.html#cb143-70"></a><span class="st">  // Choose a random scale factor (1% to 25%)</span></span>
<span id="cb143-71"><a href="regularpolygons.html#cb143-71"></a><span class="st">  std::uniform_real_distribution&lt;float&gt; rd2(0.01f, 0.25f);</span></span>
<span id="cb143-72"><a href="regularpolygons.html#cb143-72"></a><span class="st">  auto scale{rd2(m_randomEngine)};</span></span>
<span id="cb143-73"><a href="regularpolygons.html#cb143-73"></a><span class="st">  GLint scaleLocation{glGetUniformLocation(m_program, &quot;scale&quot;)};</span></span>
<span id="cb143-74"><a href="regularpolygons.html#cb143-74"></a><span class="st">  glUniform1f(scaleLocation, scale);</span></span>
<span id="cb143-75"><a href="regularpolygons.html#cb143-75"></a></span>
<span id="cb143-76"><a href="regularpolygons.html#cb143-76"></a><span class="st">  // Render</span></span>
<span id="cb143-77"><a href="regularpolygons.html#cb143-77"></a><span class="st">  glBindVertexArray(m_vao);</span></span>
<span id="cb143-78"><a href="regularpolygons.html#cb143-78"></a><span class="st">  glDrawArrays(GL_TRIANGLE_FAN, 0, sides + 2);</span></span>
<span id="cb143-79"><a href="regularpolygons.html#cb143-79"></a><span class="st">  glBindVertexArray(0);</span></span>
<span id="cb143-80"><a href="regularpolygons.html#cb143-80"></a></span>
<span id="cb143-81"><a href="regularpolygons.html#cb143-81"></a><span class="st">  glUseProgram(0);</span></span>
<span id="cb143-82"><a href="regularpolygons.html#cb143-82"></a><span class="st">}</span></span>
<span id="cb143-83"><a href="regularpolygons.html#cb143-83"></a></span>
<span id="cb143-84"><a href="regularpolygons.html#cb143-84"></a><span class="st">void OpenGLWindow::paintUI() {</span></span>
<span id="cb143-85"><a href="regularpolygons.html#cb143-85"></a><span class="st">  abcg::OpenGLWindow::paintUI();</span></span>
<span id="cb143-86"><a href="regularpolygons.html#cb143-86"></a></span>
<span id="cb143-87"><a href="regularpolygons.html#cb143-87"></a><span class="st">  {</span></span>
<span id="cb143-88"><a href="regularpolygons.html#cb143-88"></a><span class="st">    auto widgetSize{ImVec2(200, 72)};</span></span>
<span id="cb143-89"><a href="regularpolygons.html#cb143-89"></a><span class="st">    ImGui::SetNextWindowPos(ImVec2(m_viewportWidth - widgetSize.x - 5,</span></span>
<span id="cb143-90"><a href="regularpolygons.html#cb143-90"></a><span class="st">                                   m_viewportHeight - widgetSize.y - 5));</span></span>
<span id="cb143-91"><a href="regularpolygons.html#cb143-91"></a><span class="st">    ImGui::SetNextWindowSize(widgetSize);</span></span>
<span id="cb143-92"><a href="regularpolygons.html#cb143-92"></a><span class="st">    auto windowFlags{ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse |</span></span>
<span id="cb143-93"><a href="regularpolygons.html#cb143-93"></a><span class="st">                     ImGuiWindowFlags_NoTitleBar};</span></span>
<span id="cb143-94"><a href="regularpolygons.html#cb143-94"></a><span class="st">    ImGui::Begin(&quot; &quot;, nullptr, windowFlags);</span></span>
<span id="cb143-95"><a href="regularpolygons.html#cb143-95"></a></span>
<span id="cb143-96"><a href="regularpolygons.html#cb143-96"></a><span class="st">    ImGui::PushItemWidth(140);</span></span>
<span id="cb143-97"><a href="regularpolygons.html#cb143-97"></a><span class="st">    ImGui::SliderInt(&quot;Delay&quot;, &amp;m_delay, 0, 200, &quot;</span><span class="sc">%d</span><span class="st"> ms&quot;);</span></span>
<span id="cb143-98"><a href="regularpolygons.html#cb143-98"></a><span class="st">    ImGui::PopItemWidth();</span></span>
<span id="cb143-99"><a href="regularpolygons.html#cb143-99"></a></span>
<span id="cb143-100"><a href="regularpolygons.html#cb143-100"></a><span class="st">    if (ImGui::Button(&quot;Clear window&quot;, ImVec2(-1, 30))) {</span></span>
<span id="cb143-101"><a href="regularpolygons.html#cb143-101"></a><span class="st">      glClear(GL_COLOR_BUFFER_BIT);</span></span>
<span id="cb143-102"><a href="regularpolygons.html#cb143-102"></a><span class="st">    }</span></span>
<span id="cb143-103"><a href="regularpolygons.html#cb143-103"></a></span>
<span id="cb143-104"><a href="regularpolygons.html#cb143-104"></a><span class="st">    ImGui::End();</span></span>
<span id="cb143-105"><a href="regularpolygons.html#cb143-105"></a><span class="st">  }</span></span>
<span id="cb143-106"><a href="regularpolygons.html#cb143-106"></a><span class="st">}</span></span>
<span id="cb143-107"><a href="regularpolygons.html#cb143-107"></a></span>
<span id="cb143-108"><a href="regularpolygons.html#cb143-108"></a><span class="st">void OpenGLWindow::resizeGL(int width, int height) {</span></span>
<span id="cb143-109"><a href="regularpolygons.html#cb143-109"></a><span class="st">  m_viewportWidth = width;</span></span>
<span id="cb143-110"><a href="regularpolygons.html#cb143-110"></a><span class="st">  m_viewportHeight = height;</span></span>
<span id="cb143-111"><a href="regularpolygons.html#cb143-111"></a></span>
<span id="cb143-112"><a href="regularpolygons.html#cb143-112"></a><span class="st">  glClear(GL_COLOR_BUFFER_BIT);</span></span>
<span id="cb143-113"><a href="regularpolygons.html#cb143-113"></a><span class="st">}</span></span>
<span id="cb143-114"><a href="regularpolygons.html#cb143-114"></a></span>
<span id="cb143-115"><a href="regularpolygons.html#cb143-115"></a><span class="st">void OpenGLWindow::terminateGL() {</span></span>
<span id="cb143-116"><a href="regularpolygons.html#cb143-116"></a><span class="st">  glDeleteProgram(m_program);</span></span>
<span id="cb143-117"><a href="regularpolygons.html#cb143-117"></a><span class="st">  glDeleteBuffers(1, &amp;m_vboPositions);</span></span>
<span id="cb143-118"><a href="regularpolygons.html#cb143-118"></a><span class="st">  glDeleteBuffers(1, &amp;m_vboColors);</span></span>
<span id="cb143-119"><a href="regularpolygons.html#cb143-119"></a><span class="st">  glDeleteVertexArrays(1, &amp;m_vao);</span></span>
<span id="cb143-120"><a href="regularpolygons.html#cb143-120"></a><span class="st">}</span></span>
<span id="cb143-121"><a href="regularpolygons.html#cb143-121"></a></span>
<span id="cb143-122"><a href="regularpolygons.html#cb143-122"></a><span class="st">void OpenGLWindow::setupModel(int sides) {</span></span>
<span id="cb143-123"><a href="regularpolygons.html#cb143-123"></a><span class="st">  // Release previous resources, if any</span></span>
<span id="cb143-124"><a href="regularpolygons.html#cb143-124"></a><span class="st">  glDeleteBuffers(1, &amp;m_vboPositions);</span></span>
<span id="cb143-125"><a href="regularpolygons.html#cb143-125"></a><span class="st">  glDeleteBuffers(1, &amp;m_vboColors);</span></span>
<span id="cb143-126"><a href="regularpolygons.html#cb143-126"></a><span class="st">  glDeleteVertexArrays(1, &amp;m_vao);</span></span>
<span id="cb143-127"><a href="regularpolygons.html#cb143-127"></a></span>
<span id="cb143-128"><a href="regularpolygons.html#cb143-128"></a><span class="st">  // Select random colors for the radial gradient</span></span>
<span id="cb143-129"><a href="regularpolygons.html#cb143-129"></a><span class="st">  std::uniform_real_distribution&lt;float&gt; rd(0.0f, 1.0f);</span></span>
<span id="cb143-130"><a href="regularpolygons.html#cb143-130"></a><span class="st">  glm::vec3 color1{rd(m_randomEngine), rd(m_randomEngine), rd(m_randomEngine)};</span></span>
<span id="cb143-131"><a href="regularpolygons.html#cb143-131"></a><span class="st">  glm::vec3 color2{rd(m_randomEngine), rd(m_randomEngine), rd(m_randomEngine)};</span></span>
<span id="cb143-132"><a href="regularpolygons.html#cb143-132"></a></span>
<span id="cb143-133"><a href="regularpolygons.html#cb143-133"></a><span class="st">  // Minimum number of sides is 3</span></span>
<span id="cb143-134"><a href="regularpolygons.html#cb143-134"></a><span class="st">  sides = std::max(3, sides);</span></span>
<span id="cb143-135"><a href="regularpolygons.html#cb143-135"></a></span>
<span id="cb143-136"><a href="regularpolygons.html#cb143-136"></a><span class="st">  std::vector&lt;glm::vec2&gt; positions(0);</span></span>
<span id="cb143-137"><a href="regularpolygons.html#cb143-137"></a><span class="st">  std::vector&lt;glm::vec3&gt; colors(0);</span></span>
<span id="cb143-138"><a href="regularpolygons.html#cb143-138"></a></span>
<span id="cb143-139"><a href="regularpolygons.html#cb143-139"></a><span class="st">  // Polygon center</span></span>
<span id="cb143-140"><a href="regularpolygons.html#cb143-140"></a><span class="st">  positions.emplace_back(0, 0);</span></span>
<span id="cb143-141"><a href="regularpolygons.html#cb143-141"></a><span class="st">  colors.push_back(color1);</span></span>
<span id="cb143-142"><a href="regularpolygons.html#cb143-142"></a></span>
<span id="cb143-143"><a href="regularpolygons.html#cb143-143"></a><span class="st">  // Border vertices</span></span>
<span id="cb143-144"><a href="regularpolygons.html#cb143-144"></a><span class="st">  auto step{M_PI * 2 / sides};</span></span>
<span id="cb143-145"><a href="regularpolygons.html#cb143-145"></a><span class="st">  for (auto angle : iter::range(0.0, M_PI * 2, step)) {</span></span>
<span id="cb143-146"><a href="regularpolygons.html#cb143-146"></a><span class="st">    positions.emplace_back(std::cos(angle), std::sin(angle));</span></span>
<span id="cb143-147"><a href="regularpolygons.html#cb143-147"></a><span class="st">    colors.push_back(color2);</span></span>
<span id="cb143-148"><a href="regularpolygons.html#cb143-148"></a><span class="st">  }</span></span>
<span id="cb143-149"><a href="regularpolygons.html#cb143-149"></a></span>
<span id="cb143-150"><a href="regularpolygons.html#cb143-150"></a><span class="st">  // Duplicate second vertex</span></span>
<span id="cb143-151"><a href="regularpolygons.html#cb143-151"></a><span class="st">  positions.push_back(positions.at(1));</span></span>
<span id="cb143-152"><a href="regularpolygons.html#cb143-152"></a><span class="st">  colors.push_back(color2);</span></span>
<span id="cb143-153"><a href="regularpolygons.html#cb143-153"></a></span>
<span id="cb143-154"><a href="regularpolygons.html#cb143-154"></a><span class="st">  // Generate VBO of positions</span></span>
<span id="cb143-155"><a href="regularpolygons.html#cb143-155"></a><span class="st">  glGenBuffers(1, &amp;m_vboPositions);</span></span>
<span id="cb143-156"><a href="regularpolygons.html#cb143-156"></a><span class="st">  glBindBuffer(GL_ARRAY_BUFFER, m_vboPositions);</span></span>
<span id="cb143-157"><a href="regularpolygons.html#cb143-157"></a><span class="st">  glBufferData(GL_ARRAY_BUFFER, positions.size() * sizeof(glm::vec2),</span></span>
<span id="cb143-158"><a href="regularpolygons.html#cb143-158"></a><span class="st">               positions.data(), GL_STATIC_DRAW);</span></span>
<span id="cb143-159"><a href="regularpolygons.html#cb143-159"></a><span class="st">  glBindBuffer(GL_ARRAY_BUFFER, 0);</span></span>
<span id="cb143-160"><a href="regularpolygons.html#cb143-160"></a></span>
<span id="cb143-161"><a href="regularpolygons.html#cb143-161"></a><span class="st">  // Generate VBO of colors</span></span>
<span id="cb143-162"><a href="regularpolygons.html#cb143-162"></a><span class="st">  glGenBuffers(1, &amp;m_vboColors);</span></span>
<span id="cb143-163"><a href="regularpolygons.html#cb143-163"></a><span class="st">  glBindBuffer(GL_ARRAY_BUFFER, m_vboColors);</span></span>
<span id="cb143-164"><a href="regularpolygons.html#cb143-164"></a><span class="st">  glBufferData(GL_ARRAY_BUFFER, colors.size() * sizeof(glm::vec3),</span></span>
<span id="cb143-165"><a href="regularpolygons.html#cb143-165"></a><span class="st">               colors.data(), GL_STATIC_DRAW);</span></span>
<span id="cb143-166"><a href="regularpolygons.html#cb143-166"></a><span class="st">  glBindBuffer(GL_ARRAY_BUFFER, 0);</span></span>
<span id="cb143-167"><a href="regularpolygons.html#cb143-167"></a></span>
<span id="cb143-168"><a href="regularpolygons.html#cb143-168"></a><span class="st">  // Get location of attributes in the program</span></span>
<span id="cb143-169"><a href="regularpolygons.html#cb143-169"></a><span class="st">  GLint positionAttribute{glGetAttribLocation(m_program, &quot;inPosition&quot;)};</span></span>
<span id="cb143-170"><a href="regularpolygons.html#cb143-170"></a><span class="st">  GLint colorAttribute{glGetAttribLocation(m_program, &quot;inColor&quot;)};</span></span>
<span id="cb143-171"><a href="regularpolygons.html#cb143-171"></a></span>
<span id="cb143-172"><a href="regularpolygons.html#cb143-172"></a><span class="st">  // Create VAO</span></span>
<span id="cb143-173"><a href="regularpolygons.html#cb143-173"></a><span class="st">  glGenVertexArrays(1, &amp;m_vao);</span></span>
<span id="cb143-174"><a href="regularpolygons.html#cb143-174"></a></span>
<span id="cb143-175"><a href="regularpolygons.html#cb143-175"></a><span class="st">  // Bind vertex attributes to current VAO</span></span>
<span id="cb143-176"><a href="regularpolygons.html#cb143-176"></a><span class="st">  glBindVertexArray(m_vao);</span></span>
<span id="cb143-177"><a href="regularpolygons.html#cb143-177"></a></span>
<span id="cb143-178"><a href="regularpolygons.html#cb143-178"></a><span class="st">  glEnableVertexAttribArray(positionAttribute);</span></span>
<span id="cb143-179"><a href="regularpolygons.html#cb143-179"></a><span class="st">  glBindBuffer(GL_ARRAY_BUFFER, m_vboPositions);</span></span>
<span id="cb143-180"><a href="regularpolygons.html#cb143-180"></a><span class="st">  glVertexAttribPointer(positionAttribute, 2, GL_FLOAT, GL_FALSE, 0, nullptr);</span></span>
<span id="cb143-181"><a href="regularpolygons.html#cb143-181"></a><span class="st">  glBindBuffer(GL_ARRAY_BUFFER, 0);</span></span>
<span id="cb143-182"><a href="regularpolygons.html#cb143-182"></a></span>
<span id="cb143-183"><a href="regularpolygons.html#cb143-183"></a><span class="st">  glEnableVertexAttribArray(colorAttribute);</span></span>
<span id="cb143-184"><a href="regularpolygons.html#cb143-184"></a><span class="st">  glBindBuffer(GL_ARRAY_BUFFER, m_vboColors);</span></span>
<span id="cb143-185"><a href="regularpolygons.html#cb143-185"></a><span class="st">  glVertexAttribPointer(colorAttribute, 3, GL_FLOAT, GL_FALSE, 0, nullptr);</span></span>
<span id="cb143-186"><a href="regularpolygons.html#cb143-186"></a><span class="st">  glBindBuffer(GL_ARRAY_BUFFER, 0);</span></span>
<span id="cb143-187"><a href="regularpolygons.html#cb143-187"></a></span>
<span id="cb143-188"><a href="regularpolygons.html#cb143-188"></a><span class="st">  // End of binding to current VAO</span></span>
<span id="cb143-189"><a href="regularpolygons.html#cb143-189"></a><span class="st">  glBindVertexArray(0);</span></span>
<span id="cb143-190"><a href="regularpolygons.html#cb143-190"></a><span class="st">}</span></span></code></pre></div>
<p>O código completo do projeto pode ser baixado <a href="http://professor.ufabc.edu.br/~harlen.batagelo/cg/data/regularpolygons.zip">deste link</a>.</p>
<p>Agora que vimos como usar variáveis uniformes para fazer transformações geométricas no vertex shader e como organizar os dados de um VBO de diferentes maneiras, vamos ao jogo!</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="22">
<li id="fn22"><p>Como veremos posteriomente, é possível reduzir esse número com o uso de geometria indexada, mas ainda assim o consumo de memória seria alto para este caso.<a href="regularpolygons.html#fnref22" class="footnote-back">↩︎</a></p></li>
<li id="fn23"><p>Na verdade, o stride nesse caso é de 8 bytes, mas o argumento <code>0</code> serve para indicar que os atributos estão agrupados de forma “apertada”.<a href="regularpolygons.html#fnref23" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="game.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="asteroids.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": false,
"twitter": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": {}
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": null,
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection",
"scroll_highlight": true
},
"toc_float": true,
"toolbar": {
"position": "fixed"
},
"search": true,
"info": true
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
